<!DOCTYPE html>
<html>
<head>
  <style>
    /* New simplified styling */
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      background-color: #f0f0f0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
    }

    /* Simple, clean canvas styles */
    #canvas-container {
      width: 90%;
      max-width: 800px;
      height: 500px;
      background-color: #ffffff;
      border: 1px solid #e0e0e0;
      position: relative;
      margin-top: 20px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      border-radius: 8px;
    }

    /* NEW: This styles the parent div container */
    .sticker {
      position: absolute;
      width: 100px;
      height: auto;
      cursor: grab;
      user-select: none;
      transition: transform 0.1s ease-in-out;
      border: 1px dashed transparent;
      box-sizing: border-box;
    }

    /* NEW: This styles the image inside the sticker container */
    .sticker img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .sticker:hover, .sticker:focus {
      outline: none;
    }
    
    .sticker:active {
      cursor: grabbing;
      z-index: 100;
    }
    
    /* New styles for the delete button */
    .delete-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: #b4b1b1d7; /* Red background */
      color: white;
      text-align: center;
      line-height: 20px;
      cursor: pointer;
      display: none; /* Hide by default */
      z-index: 101;
      padding: 4px;
    }
    
    .sticker:hover > .delete-btn {
      display: flex; /* Show on sticker hover */
      align-items: center;
      justify-content: center;
    }

    .delete-btn-icon {
        width: 50px;
        height: 50px;
        fill: white;
        stroke: white;
    }

    .controls {
      margin-top: 20px;
      display: flex;
      gap: 10px;
    }

    .bucket-active .sticker {
  border: none !important;
  transition: none !important;
}

.bucket-active .sticker .delete-btn {
  display: none !important;
}

.bucket-active .sticker:active,
.bucket-active .sticker:hover {
  cursor: crosshair;
}


    /* Icon button styles */
    button {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: none;
      border-radius: 50%;
      background-color: #007bff;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.2s;
    }

    button:hover {
      background-color: #0056b3;
      transform: scale(1.05);
    }
    
    .icon {
      width: 1.2em;
      height: 1.2em;
      fill: none;
      stroke: currentColor;
    }

    #sticker-palette-container {
      width: 90%;
      max-width: 800px;
      margin-top: 20px;
      padding: 10px;
      background-color: #f8f8f8;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      gap: 10px;
      position: relative;
    }

    .palette-sticker {
      width: 60px;
      height: 60px;
      object-fit: contain;
      cursor: pointer;
      border: 2px solid transparent;
      transition: border-color 0.2s, transform 0.2s;
    }

    .palette-sticker:hover {
      border-color: #007bff;
      transform: scale(1.1);
    }

    #overlay-container {
      position: absolute;
      background-color: rgba(255, 255, 255, 0.95);
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 10px;
      display: none;
      z-index: 200;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      
      display: none;
      grid-template-columns: repeat(5, 1fr);
      gap: 5px;
      width: 250px;
    }

    .overlay-sticker {
      width: 100%;
      height: auto;
      aspect-ratio: 1/1;
      object-fit: contain;
      cursor: grab;
      border: 1px solid transparent;
    }
    </style>
  <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body>
  <div class="controls">
    <button id="add-sticker-btn" title="Add Random">
      <i data-lucide="dices" class="icon"></i>
    </button>

   <input type="color" id="color-picker" title="Pick Fill Color" value="#ff0000" />
<button id="bucket-btn" title="Fill Sticker">
  <i data-lucide="paint-bucket" class="icon"></i>
</button>

    <button id="undo-btn" title="Undo">
      <i data-lucide="rotate-ccw" class="icon"></i>
    </button>
    
    <button id="new-btn" title="New Canvas">
      <i data-lucide="plus-circle" class="icon"></i>
    </button>
  </div>
  <div id="canvas-container"></div>
  
  <h3>Choose a Sticker</h3>
  <div id="sticker-palette-container">
    </div>

  <div id="overlay-container"></div>


  <script>
    const stickerGroups = [
      {
        name: "Alpaca",
        urls: [
          
          "https://static.wixstatic.com/media/990059_caaa5e6cda52435fbb7c5d44baf532b6~mv2.png",
          "https://static.wixstatic.com/media/990059_91c06e8d3bd0444696cf64ff35870d79~mv2.png",
          "https://static.wixstatic.com/media/990059_2f5de7bfb37b4edf9375460f2befe73d~mv2.png",
          "https://static.wixstatic.com/media/990059_2a29f33d7ef34280b86e7786af3971d1~mv2.png",
          "https://static.wixstatic.com/media/990059_95ffdb66d7d94ad99e0471a5103defec~mv2.png"
        ]
      },
      {
        name: "80s Wrestler",
        urls: [
          "https://static.wixstatic.com/media/990059_bdb2912772b543748423fcdcd14a5511~mv2.png",
          "https://static.wixstatic.com/media/990059_33fe8d1256f64f36bb515900f04f14a6~mv2.png",
          "https://static.wixstatic.com/media/990059_7786535a11d5461f9f3a82b686538dba~mv2.png"
        ]
      }
    ];

    const canvas = document.getElementById('canvas-container');
    const addStickerBtn = document.getElementById('add-sticker-btn');
    const undoBtn = document.getElementById('undo-btn');
    const newBtn = document.getElementById('new-btn');
    const paletteContainer = document.getElementById('sticker-palette-container');
    const overlayContainer = document.getElementById('overlay-container');

    const colorHistory = [];

   const colorPicker = document.getElementById('color-picker');
const bucketBtn = document.getElementById('bucket-btn');
let bucketMode = false;

    let activeSticker = null;
    let initialX, initialY, offsetX, offsetY;
    const history = [];

    let activePaletteSticker = null;

    // --- Function to save the current canvas state to the history ---
    function saveState() {
  const stickersOnCanvas = document.querySelectorAll('#canvas-container .sticker');
  const currentState = {
    stickers: []
  };

  stickersOnCanvas.forEach(sticker => {
    const stickerImg = sticker.querySelector('img');
    if (stickerImg) {
      currentState.stickers.push({
        url: stickerImg.src,          // store the current image data (even recolored)
        x: sticker.offsetLeft,
        y: sticker.offsetTop,
        width: sticker.offsetWidth,
        height: sticker.offsetHeight
      });
    }
  });

  history.push(currentState);
  updateUndoButton();
}


    // --- Function to re-render the canvas from a saved state ---
 function loadState(state) {
  canvas.innerHTML = '';

  state.stickers.forEach(data => {
    const sticker = addSticker(data.url, data.x, data.y);
    sticker.style.width = `${data.width}px`;
    sticker.style.height = `${data.height}px`;
  });
}


    // --- Function to create and add a sticker to the canvas ---
    function addSticker(url, x, y) {
  const sticker = document.createElement('div');
  sticker.classList.add('sticker');
  
  const stickerImg = document.createElement('img');
  stickerImg.crossOrigin = "Anonymous";
stickerImg.src = url;
  stickerImg.draggable = false;

  sticker.appendChild(stickerImg);

  // --- Bucket tool handler ---
  stickerImg.addEventListener('click', (e) => {
    if (bucketMode) {
      const rect = e.target.getBoundingClientRect();
      const clickX = Math.floor((e.clientX - rect.left) * (stickerImg.naturalWidth / rect.width));
      const clickY = Math.floor((e.clientY - rect.top) * (stickerImg.naturalHeight / rect.height));
      recolorSticker(stickerImg, colorPicker.value, clickX, clickY);
      e.stopPropagation();
      saveState();
    }
  });

  // --- Delete button setup (your existing code) ---
  const deleteBtn = document.createElement('div');
  deleteBtn.classList.add('delete-btn');
  deleteBtn.innerHTML = `
    <svg class="delete-btn-icon" viewBox="0 0 24 24">
      <line x1="15" y1="9" x2="9" y2="15"></line>
      <line x1="9" y1="9" x2="15" y2="15"></line>
    </svg>
  `;
  deleteBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    sticker.remove();
    saveState();
  });
  sticker.appendChild(deleteBtn);

  // --- Positioning ---
  let finalX = x ?? Math.floor(Math.random() * (canvas.offsetWidth - 100));
  let finalY = y ?? Math.floor(Math.random() * (canvas.offsetHeight - 100));

  sticker.style.left = `${finalX}px`;
  sticker.style.top = `${finalY}px`;

  // --- Drag/Resize listeners (your existing code) ---
stickerImg.addEventListener('mousedown', (e) => {
  if (!bucketMode) {
    startDrag(e);
  }
});  addResizeListener(stickerImg);

  canvas.appendChild(sticker);
  saveState();
  return sticker;
}

    
    // --- Function to populate the sticker palette with main groups ---
    function populatePalette() {
      stickerGroups.forEach(group => {
        const paletteSticker = document.createElement('img');
        paletteSticker.src = group.urls[0];
        paletteSticker.classList.add('palette-sticker');
        
        paletteSticker.dataset.group = group.name;

        paletteSticker.addEventListener('click', (e) => {
          if (activePaletteSticker === paletteSticker) {
            hideOverlay();
          } else {
            hideOverlay();
            showOverlay(e, group.urls);
            activePaletteSticker = paletteSticker;
          }
        });
        
        // Add drag/drop functionality for the main image
        paletteSticker.draggable = true;
        paletteSticker.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', group.urls[0]);
          hideOverlay();
        });
        paletteContainer.appendChild(paletteSticker);
      });
    }
    
    // --- Hide overlay function ---
    function hideOverlay() {
      overlayContainer.style.display = 'none';
      activePaletteSticker = null;
    }

    // --- Overlay functions ---
    let activeGroupURLs = [];
    
    function showOverlay(e, urls) {
      activeGroupURLs = urls;

      overlayContainer.innerHTML = '';
      
      urls.forEach(url => {
        const overlaySticker = document.createElement('img');
        overlaySticker.src = url;
        overlaySticker.classList.add('overlay-sticker');
        
        overlaySticker.draggable = true;
        overlaySticker.addEventListener('dragstart', (e) => {
          e.stopPropagation();
          e.dataTransfer.setData('text/plain', url);
        });
        overlaySticker.addEventListener('click', (e) => {
          e.stopPropagation();
          addSticker(url);
        });
        
        overlayContainer.appendChild(overlaySticker);
      });

      const rect = e.target.getBoundingClientRect();
const paletteRect = paletteContainer.getBoundingClientRect();

const { right, bottom } = rect;

if (right + 260 < window.innerWidth) {
  overlayContainer.style.left = `${rect.right - paletteRect.left + 10}px`;
} else {
  overlayContainer.style.left = `${rect.left - paletteRect.left - 260}px`;
}

// keep your vertical positioning check
if (bottom + overlayContainer.offsetHeight < window.innerHeight) {
  overlayContainer.style.top = `${rect.top - paletteRect.top}px`;
} else {
  overlayContainer.style.top = `${rect.top - paletteRect.top - overlayContainer.offsetHeight}px`;
}
      
      overlayContainer.style.display = 'grid';
    }
    
    document.addEventListener('click', (e) => {
      if (!paletteContainer.contains(e.target) && !overlayContainer.contains(e.target)) {
        hideOverlay();
      }
    });

    // --- Drag-and-Drop event listeners for the canvas ---
    canvas.addEventListener('dragover', (e) => {
      e.preventDefault();
    });

    canvas.addEventListener('drop', (e) => {
      e.preventDefault();
      const url = e.dataTransfer.getData('text/plain');
      if (url) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        addSticker(url, x, y);
      }
    });

  function addResizeListener(stickerImg) {
  stickerImg.addEventListener('wheel', (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    const parent = stickerImg.parentElement;
    const newSize = parent.offsetWidth + (delta * 10);
    const minSize = 30, maxSize = 400;
    if (newSize >= minSize && newSize <= maxSize) {
      parent.style.width = `${newSize}px`;
      parent.style.height = 'auto';
    }
  });
}

function hexToRgb(hex) {
  hex = hex.replace(/^#/, "");
  const bigint = parseInt(hex, 16);
  return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
}

function recolorSticker(stickerImg, fillColor, clickX, clickY) {
  // Save current state before changing
  colorHistory.push({
    sticker: stickerImg,
    prevSrc: stickerImg.src
  });
  updateUndoButton();

  const canvasEl = document.createElement("canvas");
  const ctx = canvasEl.getContext("2d");
  canvasEl.width = stickerImg.naturalWidth;
  canvasEl.height = stickerImg.naturalHeight;
  ctx.drawImage(stickerImg, 0, 0);

  const imgData = ctx.getImageData(0, 0, canvasEl.width, canvasEl.height);
  const data = imgData.data;

  const [r, g, b] = hexToRgb(fillColor);

  const startIndex = ((clickY * canvasEl.width) + clickX) * 4;
  const startR = data[startIndex];
  const startG = data[startIndex + 1];
  const startB = data[startIndex + 2];
  const startA = data[startIndex + 3];

  // helper: is black outline pixel?
  const isBlack = (r, g, b, a) => (r === 0 && g === 0 && b === 0 && a > 0);

  // If clicked on black outline → search for nearby transparent pixel
  if (isBlack(startR, startG, startB, startA)) {
    let found = false;
    const offsets = [[1,0],[-1,0],[0,1],[0,-1]];
    for (const [dx, dy] of offsets) {
      const nx = clickX + dx;
      const ny = clickY + dy;
      if (nx < 0 || ny < 0 || nx >= canvasEl.width || ny >= canvasEl.height) continue;
      const ni = ((ny * canvasEl.width) + nx) * 4;
      if (data[ni+3] === 0) {
        clickX = nx; clickY = ny;
        found = true;
        break;
      }
    }
    if (!found) return; // nothing to fill
  }

  // Flood fill to detect region
  const stack = [[clickX, clickY]];
  const visited = new Set();
  let touchesEdge = false;

  while (stack.length) {
    const [x, y] = stack.pop();
    if (x < 0 || y < 0 || x >= canvasEl.width || y >= canvasEl.height) {
      touchesEdge = true;
      continue;
    }
    const i = ((y * canvasEl.width) + x) * 4;
    const key = `${x},${y}`;
    if (visited.has(key)) continue;
    visited.add(key);

    if (isBlack(data[i], data[i+1], data[i+2], data[i+3])) continue;

    // Candidate region pixel (transparent or colored)
    stack.push([x+1, y]);
    stack.push([x-1, y]);
    stack.push([x, y+1]);
    stack.push([x, y-1]);
  }

  // If region touches border → it's outside background → skip
  if (touchesEdge) return;

  // Otherwise fill all visited pixels
  for (const key of visited) {
    const [x, y] = key.split(",").map(Number);
    const i = ((y * canvasEl.width) + x) * 4;
    data[i] = r;
    data[i+1] = g;
    data[i+2] = b;
    data[i+3] = 255;
  }

  ctx.putImageData(imgData, 0, 0);
  stickerImg.src = canvasEl.toDataURL();
}

    // --- Dragging functions for stickers on the canvas ---
    function startDrag(e) {
      
      e.preventDefault();
      activeSticker = e.target;
      initialX = e.clientX;
      initialY = e.clientY;
      offsetX = activeSticker.parentElement.offsetLeft;
      offsetY = activeSticker.parentElement.offsetTop;
      
      document.addEventListener('mousemove', dragSticker);
      document.addEventListener('mouseup', stopDrag);
    }

    function dragSticker(e) {
      if (!activeSticker) return;
      const newX = offsetX + (e.clientX - initialX);
      const newY = offsetY + (e.clientY - initialY);
      const maxX = canvas.offsetWidth - activeSticker.parentElement.offsetWidth;
      const maxY = canvas.offsetHeight - activeSticker.parentElement.offsetHeight;
      activeSticker.parentElement.style.left = `${Math.min(Math.max(0, newX), maxX)}px`;
      activeSticker.parentElement.style.top = `${Math.min(Math.max(0, newY), maxY)}px`;
    }

    function stopDrag() {
       if (bucketMode) {
     return;
   }
      document.removeEventListener('mousemove', dragSticker);
      document.removeEventListener('mouseup', stopDrag);
      activeSticker = null;
    }

    // --- New: Undo and New button event listeners ---
  function updateUndoButton() {
  undoBtn.disabled = colorHistory.length === 0;
}

    undoBtn.addEventListener('click', () => {
  if (colorHistory.length > 0) {
    const last = colorHistory.pop();
    last.sticker.src = last.prevSrc;  // restore old image
  }
  updateUndoButton();
});


    newBtn.addEventListener('click', () => {
      canvas.innerHTML = '';
      history.splice(1);
      updateUndoButton();
    });
    
    // --- Initial function calls ---
    addStickerBtn.addEventListener('click', () => {
      const allUrls = stickerGroups.flatMap(group => group.urls);
      const randomUrl = allUrls[Math.floor(Math.random() * allUrls.length)];
      addSticker(randomUrl);
    });
    
    populatePalette();
    saveState();
    
      // New: Manually create icons after the page has loaded
    window.addEventListener('load', () => {
      if (window.lucide) {
        lucide.createIcons();
      }
    });


    // Toggle bucket mode
bucketBtn.addEventListener('click', () => {
  bucketMode = !bucketMode;
  bucketBtn.style.backgroundColor = bucketMode ? "#28a745" : "#007bff";
  
  if (bucketMode) {
    document.body.classList.add('bucket-active');
    canvas.style.cursor = 'crosshair';
  } else {
    document.body.classList.remove('bucket-active');
    canvas.style.cursor = 'default';
  }
});
    
  </script>
  
</body>
</html>
