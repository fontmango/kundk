<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sticker Canvas</title>
    <style>
      
      img.protected {
  -webkit-touch-callout: none; /* disable "Save Image" on iOS Safari */
  -webkit-user-select: none;   /* prevent text/image selection */
  -webkit-user-drag: none;     /* prevent dragging image to new tab */
  user-select: none;
}
      
  .sticker-btn {
    position: absolute;
    width: 20%;
    height: 20%;
    border-radius: 50%;
    background-color: #c2bebeff;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 101;
    padding: 0;
    outline: none;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s ease, visibility 0.2s ease, transform 0.2s, background-color 0.2s;
}

/* Show buttons on hover or selected sticker */
.sticker:hover > .sticker-btn,
.sticker.selected > .sticker-btn {
    opacity: 1;
    visibility: visible;
}

/* Specific button positions */
.delete-btn {
    top: 5%;
    right: 5%;
}

.copy-btn {
    top: 5%;
    left: 5%;
}

.group-btn:hover {
    background-color: #2be7d8; /* A subtle hover color */
    transform: scale(1.1);
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
}

.group-btn {
    bottom: 5%;
    right: 5%;
}

/* Hover effects */
.sticker-btn:hover {
    transform: scale(1.1);
   
}

.sticker.locked .lock-btn {
    background-color: #ff9933; /* Override to orange when locked */
}


/* SVG sizing inside buttons */
.sticker-btn svg {
    width: 60%;
    height: 60%;
}

body {
    margin: 0;
    padding: 0;
    font-family: 'Inter', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
  
    box-sizing: border-box;
    overflow-x: hidden;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

#canvas-container {
    width: 90%;
    max-width: 600px;
    height: 80vh;
    background-color: #ffffff;
    border: 1px solid #e0e0e0;
    position: relative;
    margin-top: 10px;
    overflow: hidden;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    border-radius: 16px;
    touch-action: none;
}
      
      @media (max-width: 768px) {
    #canvas-container {
        /* On mobile, make the height 50% of the screen's height */
  
        /* You can also make it take the full width for more space */
        width: 100%;
    }
}

.sticker {
    position: absolute;
    height: auto;
    cursor: grab;
    user-select: none;
    box-sizing: border-box;
    touch-action: none;
}

.sticker img {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

.sticker:active {
    cursor: grabbing;
    z-index: 100;
}

.sticker.locked {
    cursor: grab;
}

.sticker.locked:active {
    cursor: grabbing;
}

.sticker:focus {
    outline: none;
}

/* Base styles for buttons, with transitions for smooth fading */
.copy-btn,
.group-btn,
.delete-btn,
.lock-btn {
    position: absolute;
    width: 20%;
    height: 20%;
    border-radius: 50%;
    background-color: #c2bebeff;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 101;
    padding: 0;
    outline: none;
    -webkit-tap-highlight-color: transparent;

    /* These are the crucial lines for hiding and transitioning */
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s ease, visibility 0.2s ease, transform 0.2s, background-color 0.2s;
}

/* Specific button positions */
.delete-btn {
    top: 5%;
    right: 5%;
}

.copy-btn {
    top: 5%;
    left: 5%;
}


.group-btn svg {
    width: 16px;
    height: 16px;
}

/* Show buttons on hover or when the sticker has the 'selected' class */
.sticker:hover > .delete-btn,
.sticker:hover > .copy-btn,
.sticker:hover > .lock-btn,
.sticker.selected > .delete-btn,
.sticker.selected > .copy-btn,
.sticker.selected > .lock-btn {
    opacity: 1;
    visibility: visible;
}

/* Hover effects for buttons */
.copy-btn:hover {
    background-color: #6aa84fff;
    transform: scale(1.1);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.delete-btn:hover {
    background-color: #f26262ff;
    transform: scale(1.1);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.lock-btn:hover {
    transform: scale(1.1);
   
    
}



/* Bucket mode-specific overrides */
.bucket-active .sticker {
    border: none !important;
    transition: none !important;
}

.bucket-active .sticker .delete-btn,
.bucket-active .sticker .copy-btn,
.bucket-active .sticker .lock-btn,
.bucket-active .sticker .group-btn {
    display: none !important;
}

.bucket-active .sticker:active,
.bucket-active .sticker:hover {
    cursor: crosshair;
}

/* ... (rest of your CSS) ... */

/* Remaining CSS from your provided code */
.controls {
    display: flex;
    gap: 10px;
    align-items: center;
}

.ghost-sticker {
    position: fixed;
    pointer-events: none;
    z-index: 1000;
    opacity: 0.7;
    width: 100px;
    height: auto;
    transform: translate(-50%, -50%);
}

button {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: none;
    background: none;
    cursor: pointer;
    color: #333;
    transition: transform 0.2s, color 0.2s;
    outline: none;
    -webkit-tap-highlight-color: transparent;
}

button:focus,
button:active {
    outline: 0 !important;
    box-shadow: none !important;
}

button:hover {
    color: #000;
    transform: scale(1.1);
}

button.active {
    border-radius: 50%;
    background-color: #e0e0e0;
    transform: scale(1.05);
}

.icon {
    width: 1.4em;
    height: 1.4em;
    stroke: currentColor;
}

.color-palette-container {
    width: 90%;
    max-width: 600px;
    overflow-x: scroll;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    -ms-overflow-style: none;
    touch-action: pan-y;
}

.color-palette-container::-webkit-scrollbar {
    display: none;
}

.color-palette {
    display: flex;
    flex-wrap: nowrap;
    gap: 8px;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 3px;
    width: max-content;
}

.color-swatch {
    width: 25px;
    height: 25px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid transparent;
    transition: transform 0.2s, border-color 0.2s;
    flex-shrink: 0;
    outline: 0 !important;
    box-shadow: none !important;
    -webkit-tap-highlight-color: transparent;
    touch-action: none;
}

.color-swatch.active {
    transform: scale(1.2);
    border-color: #000000;
}

#sticker-palette-container {
    display: none;
}

.overlay {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(255, 255, 255, 0.95);
    border: 1px solid #ccc;
    border-radius: 8px;
    padding: 10px;
    display: none;
    z-index: 200;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    width: 80%;
   
    overflow-y: auto;
    grid-template-columns: repeat(5, 1fr);
    gap: 10px;
}


.overlay.active {
    display: block;
}

.overlay-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 10px;
    overflow-y: auto;
    height: calc(100% - 40px);
    width: 100%;
}

.overlay-icon {
   
    max-width: 100%; /* Ensures it scales down on smaller screens */
    height: auto;
    aspect-ratio: 1/1;
    object-fit: contain;
    cursor: pointer;
    border-radius: 8px;
    transition: transform 0.2s;
    transform: scale(1);
    -webkit-tap-highlight-color: transparent;
    -webkit-focus-ring-color: transparent;
    outline: none;
}

.overlay-icon:hover {
¬† ¬† transform: scale(1.1);
}



.overlay-sticker {
    width: 100%;
    height: auto;
    aspect-ratio: 1/1;
    object-fit: contain;
    cursor: pointer;
    border: 1px solid transparent;
    transition: transform 0.2s;
 -webkit-tap-highlight-color: transparent; /* iOS/Android WebKit */
  -webkit-focus-ring-color: transparent;    /* iOS Safari */
  outline: none;      
  
}

.overlay-sticker.active {
  position: relative;
}

.overlay-sticker.active::after {
  content: "";
  position: absolute;
  top: -5px;
  left: -5px;
  right: -5px;
  bottom: -5px;
  border-radius: 12px; /* adjust to match sticker shape */
  border: 2px solid #00bfff; /* pulse color */
  animation: pulse 1.5s infinite;
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.15);
  }
}



.overlay-sticker:hover {
    transform: scale(1.1);
}

.copy-btn-icon {
    width: 100%;
    height: 100%;
    fill: white;
    stroke: white;
}

.lock-btn-icon {
    width: 60%;
    height: 60%;
    fill: white;
    stroke: white;
}

.delete-btn-icon {
    width: 100%;
    height: 100%;
    fill: white;
    stroke: white;
}


.copy-btn:hover {
    background-color: #6aa84fff;
    transform: scale(1.1);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.delete-btn:hover {
    background-color: #f26262ff;
    transform: scale(1.1);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.pulse-effect {
  animation: pulse 0.5s ease-in-out;
}


#sticker-overlay-container {
    /* Main overlay styles */
    position: absolute;
    top: 45%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90vw;
   
    background-color: #fff;
    border-radius: 16px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.15);
    padding: 0; /* Remove padding here, add it to the content wrapper */
    z-index: 300;
    
    /* Crucial for centering and stacking header/content */
    display: none; /* Hide by default */
    flex-direction: column; 
  
}

/* Other CSS remains the same */

.overlay-stickers-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
    gap: 10px;
    padding: 5px;
    max-height: 70vh; /* Adjust as needed */
    overflow-y: auto;
}

.overlay-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    background: white;
    border-bottom: 1px solid #ccc;
    flex-shrink: 0;
}


.close-btn {
    position: absolute;
   
    
    color: #555;
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}


.close-btn {
    right: 0;
}

.overlay-close-btn:hover {
    transform: scale(1.1);
}

#group-overlay-container {
    position: fixed;
    top: 45%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(255, 255, 255, 0.95);
    border: 1px solid #ccc;
    border-radius: 8px;
    padding: 10px;
    display: none;
    z-index: 200;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    width: 80%;
    max-width: 500px;
    max-height: 80vh;
    overflow-y: auto;
    
    /* Change to flexbox for vertical stacking */
    display: none;
    flex-direction: column;
}

.overlay-icons-grid {
    /* Apply grid properties to the new container for icons */
    display: grid; 
    grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
    gap: 10px;
    padding: 10px 0; /* Adjust padding as needed */
}

.overlay-title {
    flex-grow: 1;
    text-align: center;
    /* This is the key change: remove the default margin from the title */
    margin: 0;
    font-size: 16px; /* Adjust font size as needed */
    font-weight: 600;
}

 #folder {
    position: absolute;
    bottom: 20px;
    right: 20px;
    width: 60px;
    height: 60px;
    
    border: 2px dotted #ccc;
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    transition: background-color 0.3s, transform 0.3s, border-color 0.3s;
    z-index: 100;
}

#folder:hover {
    background-color: #d0d0d0;
    transform: scale(1.05);
}

#folder.drag-over {
  background: rgba(0, 200, 0, 0.1);
  box-shadow: 0 0 12px rgba(0, 200, 0, 0.6);
  border-radius: 12px;
  transform: scale(1.05);
  transition: all 0.2s ease;
}

.folder-icon {
    width: 25px;
    height: 25px;
    stroke: #888;
}

#folder-count {
  position: absolute;
  top: -8px;     /* move a bit higher to account for size */
  right: -8px;   /* move more right to overlap nicely */
  background: white;
  font-size: 14px;
  font-weight: bold;
  min-width: 24px; /* wider so numbers like 10+ fit */
  height: 24px;
  line-height: 24px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 4px rgba(0,0,0,0.4);
}
#folder-overlay {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 80%;
  height: 80%;
  background: white;
  border-radius: 12px;
  padding: 20px;
  overflow-y: auto;
  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  gap: 12px;
  z-index: 10000;
   border: 1px solid #ccc;
            border-radius: 8px;
}

#folder-overlay .overlay-close {
  position: absolute;
  top: 8px;   /* move it further up */
  right: 8px; /* move it further right */
  z-index: 9999;
  background: #444;
  color: white;
  border: none;
  border-radius: 50%;
  width: 28px;
  height: 28px;
  font-size: 18px;
  line-height: 28px;
  text-align: center;
  cursor: pointer;
}

/* Disable any pointer style on the wrapper */
#folder-overlay .overlay-sticker-wrapper {
  position: relative;
  display: inline-block;
}

#folder-overlay .overlay-sticker {
  transform: none !important;
  box-shadow: none !important;
  border: none !important;
  cursor: default !important;
}


#folder-overlay .overlay-sticker:hover {
  transform: none !important;
  box-shadow: none !important;
  border: none !important;
  cursor: default !important;
}

/* delete button inside wrapper */
#folder-overlay .overlay-sticker-wrapper .delete-sticker-btn {
  position: absolute;
  top: 4px;
  right: 4px;
  background: #c2bebeff;
  color: white;
  border: none;
  border-radius: 50%;
  width: 22px;
  height: 22px;
  font-size: 16px;
  line-height: 20px;
  text-align: center;
  cursor: pointer;
  display: block;
}

#folder-overlay .overlay-sticker-wrapper .delete-sticker-btn:hover {
  background-color: #f26262ff;
}

#folder.full {
  border-color: red;
}

#folder.full .folder-icon {
  filter: hue-rotate(-50deg) saturate(5); /* tint to red */
  /* Or use: color: red; if it's an SVG or font icon */
}

/* Folder icon inside */
#folder.full .folder-icon {
  filter: hue-rotate(-50deg) saturate(5); /* tint to red */
  /* Or use: color: red; if it's an SVG or font icon */
}

/* The count */
#folder.full .folder-count {
  color: red;
  font-weight: bold;
}

@keyframes shake {
  0% { transform: translateX(0); }
  20% { transform: translateX(-5px); }
  40% { transform: translateX(5px); }
  60% { transform: translateX(-5px); }
  80% { transform: translateX(5px); }
  100% { transform: translateX(0); }
}

.overlay-save {
 
  border: none;
  border-radius: 6px;
  font-weight: bold;
  cursor: pointer;
  background: black;
  color: white;
  transition: background 0.2s, color 0.2s, opacity 0.2s;
}

.overlay-save:disabled {
  background: #ccc;   /* grey background */
  color: #666;        /* faded text */
  cursor: not-allowed;
  opacity: 0.7;
}

.controls.disabled button {
  pointer-events: none;
  opacity: 0.4;
}

#email-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(1);
  background: #fff;
  padding: 24px 20px;
  border-radius: 16px;
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.25);
  z-index: 11000;
  width: 320px;
  text-align: center;
  font-family: "Inter", sans-serif;
  transition: transform 0.2s ease, opacity 0.2s ease;
}

#email-popup.hidden {
  display: none;
  opacity: 0;
  transform: translate(-50%, -50%) scale(0.9);
}

#email-popup h3 {
  margin: 0 0 16px;
  font-size: 1.2rem;
  color: #333;
}

#email-popup input {
  width: 100%;
  padding: 10px 12px;
  margin: 12px 0;
  border: 1px solid #ddd;
  border-radius: 8px;
  font-size: 0.95rem;
  outline: none;
  transition: border-color 0.2s, box-shadow 0.2s;
  box-sizing: border-box; /* ‚úÖ keeps it inside the popup */
}
#email-popup input:focus {
  border-color: #0078ff;
  box-shadow: 0 0 0 2px rgba(0, 120, 255, 0.2);
}

#email-popup .popup-actions {
  display: flex;
  justify-content: space-between;
  margin-top: 14px;
  gap: 10px;
}

#email-popup button {
  flex: 1;
  padding: 10px 0;
  border: none;
  border-radius: 8px;
  font-size: 0.95rem;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.2s, transform 0.1s;
}

#email-popup #cancel-btn {
  background: #f2f2f2;
  color: #333;
}

#email-popup #cancel-btn:hover {
  background: #e0e0e0;
}

#email-popup #send-btn {
  background: #0078ff;
  color: white;
}

#email-popup #send-btn:hover {
  background: #0063cc;
}

#email-popup button:active {
  transform: scale(0.96);
}

#success-popup {
  position: fixed; /* make it consistent with loading & email */
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.25);
  z-index: 11001;
  text-align: center;
}


#success-popup.hidden {
  display: none;
}

.success-box p {
  margin-bottom: 10px;
  font-size: 16px;
}

.popup {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.2);
  z-index: 2000;
 
}

/* Loading popup */
#loading-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.2);
  z-index: 11001;
  text-align: center;
}

#loading-popup .popup-content {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 16px;
  
}

.hidden {
  display: none !important;
}

.dots::after {
  content: '';
  animation: dots 1.5s steps(3, end) infinite;
}

@keyframes dots {
  0%   { content: ''; }
  33%  { content: '.'; }
  66%  { content: '..'; }
  100% { content: '...'; }
}

#success-popup .success-ok-btn {
  background-color: #28a745;   /* nice green */
  color: white;
  border: none;
  border-radius: 8px;
  padding: 12px 24px;
  font-size: 18px;
  font-weight: bold;
  cursor: pointer;
  margin-top: 15px;
  transition: background-color 0.2s ease, transform 0.1s ease;
}

#success-popup .success-ok-btn:hover {
  background-color: #218838;
}

#success-popup .success-ok-btn:active {
  transform: scale(0.96);
}

#error-message {
  color: red;
  font-size: 13px;
  margin-top: -5px;
  margin-bottom: 8px;
  text-align: left;
}

#email-input.error {
  border: 1px solid red;
  outline: none;
}


#folder.success.pulse {
  animation: folderPulseGreen 0.5s ease;
}

@keyframes folderPulseGreen {
  0%   { transform: scale(1); box-shadow: 0 0 0px rgba(0, 200, 0, 0.6); }
  50%  { transform: scale(1.1); box-shadow: 0 0 15px rgba(0, 200, 0, 0.8); }
  100% { transform: scale(1); box-shadow: 0 0 0px rgba(0, 200, 0, 0.6); }
}

/* ‚ùå Red pulse (full) */
#folder.full.shake {
  animation: folderPulseRed 0.5s ease, shake 0.6s ease;
}

@keyframes folderPulseRed {
  0%   { transform: scale(1); box-shadow: 0 0 0px rgba(200, 0, 0, 0.6); }
  50%  { transform: scale(1.1); box-shadow: 0 0 15px rgba(200, 0, 0, 0.8); }
  100% { transform: scale(1); box-shadow: 0 0 0px rgba(200, 0, 0, 0.6); }
}

/* Shake effect */
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}

.pulse-effect {
  animation: pulse 0.5s ease-in-out;
}

@keyframes pulse {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.1);
  }
  100% {
    transform: scale(1);
  }
}


#price-notification {
  position: absolute;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%) translateY(0);
  background: #28a745; /* ‚úÖ Green */
  color: white;
  padding: 6px 14px;
  border-radius: 20px;
  font-size: 14px;
  opacity: 0;
  pointer-events: none;
  z-index: 999;
}

#price-notification.show {
  animation: floatUp 1.8s ease-out forwards; /* slightly slower */
}

@keyframes floatUp {
  0% {
    opacity: 0;
    transform: translateX(-50%) translateY(0) scale(0.9);
  }
  15% {
    opacity: 1;
    transform: translateX(-50%) translateY(-10px) scale(1.05);
  }
  70% {
    opacity: 1;
    transform: translateX(-50%) translateY(-40px) scale(1);
  }
  100% {
    opacity: 0;
    transform: translateX(-50%) translateY(-55px) scale(1);
  }
}

#folder-total-price {
    text-align: right;
    font-weight: bold;
    padding: 10px;
    border-top: 1px solid #ccc;
    font-size: 16px;
}
    </style>

    <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body>
  


    <div id="canvas-container">
  <div id="stickers-layer"></div>
  <div id="folder" title="Drop stickers here to add to cart">
    <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 24 24" fill="none" 
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="cart-icon lucide-shopping-cart">
      <circle cx="9" cy="21" r="1" />
      <circle cx="20" cy="21" r="1" />
      <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6" />
    </svg>
    <span id="folder-count"></span>

  </div>
</div>
    <div id="overlay-container"></div>
<div id="price-notification" class="hidden"></div>


  <div class="controls">
  
   <button id="spin-sticker-btn" title="Spin Random">
  <i data-lucide="dice-6" class="icon"></i>
</button>
    
        <button id="add-sticker-btn" title="Add Random">
            <i data-lucide="plus" class="icon"></i>
        </button>

        <button id="sticker-picker-btn" title="Choose Sticker">
            <i data-lucide="sticker" class="icon"></i>
        </button>

        <button id="undo-btn" title="Undo">
            <i data-lucide="undo-2" class="icon"></i>
        </button>

        <button id="redo-btn" title="Redo">
            <i data-lucide="redo-2" class="icon"></i>
        </button>
        
         <button id="new-btn" title="Neu">
            <i data-lucide="file-plus-2" class="icon"></i>
        </button>

     

    </div>
  
  
    <div class="color-palette-container">
        <div class="color-palette" id="color-palette"></div>
    </div>
        <div id="sticker-overlay-container"></div>

 <div id="folder-overlay">
  <div id="folder-total-price">
    Total: $<span id="folder-price-value">0.00</span>
  </div>
 </div> 

    <div id="group-overlay-container" ></div>

    <!-- Email Popup -->
<div id="email-popup" class="email-popup hidden">
  <h3>Enter your email</h3>
  <input type="email" id="email-input" placeholder="your@email.com" required />
  <div id="email-error" class="error-message"></div>
  
  <div class="popup-actions">
    <button id="cancel-btn">Cancel</button>
    <button id="send-btn">Send</button>
  </div>
</div>

<div id="success-popup" class="hidden">
  <div class="success-box">
    <p id="success-message">Stickers saved successfully!</p>
    <div id="uuid-container" class="hidden">
      <span id="uuid-text"></span>
      <button id="copy-uuid-btn">Copy</button>
          <button id="go-to-url-btn" class="success-ok-btn">Go</button>

    </div>
    <button id="success-ok-btn" class="success-ok-btn">OK</button>
  </div>
</div>

<div id="loading-popup" class="hidden">
  <div class="popup-content">
    <p>Sticker werden gespeichert<span class="dots"></span></p>
  </div>
</div>

    <script>
           
                 
                    const stickerGroups = [
   
    {
        "name": "dia de los muerstos sticker",
        "urls": [
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_018f7140-17fb-427f-8d4e-e9d937d35912.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_043b10f9-ae16-4ffa-a84d-ab4eb4f4c3e6.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_0f54dae6-7218-4d0e-a07e-a9fcacb6854c.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_14501777-c72d-4e47-a2cf-904e41d5e3eb.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_3093434e-c31e-4fd6-b98b-61a7a02fb701.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_323a0239-234e-46bf-be96-8d072e9d37e6.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_326472f5-ea67-4ba1-b861-347910730bd9.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_3c7f26a1-8aeb-4f2f-9784-8cdd80a10cd2.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_3d6ae4e9-416b-4fbb-8138-4dcbf28a73b3.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_412565e9-f3c6-48f8-a7ec-b5abb985dba4.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_4a73b5b1-5f28-4e7c-9882-57c265b835e9.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_531b4ef5-0b7d-4456-8617-8f285580cda9.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_57a57795-a766-4c62-87fa-d3f68a162a6c.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_71adb5c1-da91-42bb-a95c-7841ad9e9aaa.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_75d97df2-bc42-4261-89f3-c1708e013cd2.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_786c01bd-5560-4318-82f8-d0b03afae60b.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_7b29b5e1-c0e7-4c95-8b08-c481f1903969.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_7dbbbaad-0689-4d0a-ab7c-52e6ac25e3f3.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_8a1a5ac9-82f1-4a34-b817-6be798b7eabf.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_923133f2-c758-4176-81ce-a2a524103d5c.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_9685c75a-b4eb-4a80-bb68-cad194927555.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_a6b95520-d474-4d7d-91e4-d1e1ed8ebe99.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_ab6f7dfd-41b9-42fe-a442-12d435a6c1b1.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_b33bafca-c4b5-4a65-91dd-8beb7af4ec3b.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_be97c247-8244-4746-a744-3e9b79f300d1.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_c48bc274-0799-4414-9c70-92cfef5b3bfc.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_c666c06f-8f5a-4120-be6e-078188bc982a.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_d03c3f7a-9db6-48da-9516-9887040be166.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_d58dcc29-a179-4223-835e-de1dd916f02d.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_e4ced13d-2836-44fe-bdd7-6ba0832fe85f.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_eba76029-c40a-4ad4-bc25-09904f622dfd.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_efacc4d9-2e13-4f23-bfa3-fdc3584d3241.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_f16105e7-ee73-48af-ad87-820f8425355f.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_f3d426fe-4667-4b25-99f6-18b025aad3b9.png",
            "https://raw.githubusercontent.com/phoneticgenius/wix_assets/main/dia de los muerstos sticker/_f9c72608-0033-4d63-8a3f-99a80ecefc7c.png"
        ]
    }
]


const redirectUrls = [
  "", // index 0 unused, so urlAmount 1 = index 1
  "https://www.fontmango.com/product-page/stickers-by-fontmango-com?origin=shopping+cart",
  "https://example.com/2",
  "https://example.com/3",
  "https://example.com/4",
  "https://example.com/5",
  "https://example.com/6",
  "https://example.com/7",
  "https://example.com/8",
  "https://example.com/9",
  "https://example.com/10",
  "https://example.com/11",
  "https://example.com/12",
  "https://example.com/13",
  "https://example.com/14",
  "https://example.com/15",
  "https://example.com/16",
  "https://example.com/17",
  "https://example.com/18",
  "https://example.com/19",
  "https://example.com/20",
  "https://example.com/21",
  "https://example.com/22",
  "https://example.com/23",
  "https://example.com/24",
  "https://example.com/25"
];

let currentRedirectUrl = ""; // store the URL for the button
let currentUuid = "";        // store UUID for copy

const folderPriceValue = document.getElementById('folder-price-value');
const folder = document.getElementById('folder');
const folderCount = document.getElementById('folder-count');
let folderUrls = [];
const MAX_FOLDER_IMAGES = 25;
const folderOverlay = document.getElementById('folder-overlay');
const saveBtn = document.getElementById("save-btn");
const popup = document.getElementById("email-popup");
const cancelBtn = document.getElementById("cancel-btn");
const sendBtn = document.getElementById("send-btn");
const emailInput = document.getElementById("email-input");

folderCount.textContent = `0`
const priceNotification = document.getElementById("price-notification");
// Our pricing tiers
const pricingTiers = [
    { max: 1, price: 0.50 },
    { max: 5, price: 0.25 },
    { max: 15, price: 0.15 },
    { max: 25, price: 0.10 }
];

const spinBtn = document.getElementById("spin-sticker-btn");

        const canvas = document.getElementById('canvas-container');
        const addStickerBtn = document.getElementById('add-sticker-btn');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const swatch = document.querySelector('.color-swatch');
        const colorPicker = document.getElementById('color-picker');
                const newBtn = document.getElementById('new-btn');


        const colorPalette = document.getElementById('color-palette');
        const history = [];

        const stickerPickerBtn = document.getElementById('sticker-picker-btn');
        const groupOverlayContainer = document.getElementById('group-overlay-container');
        const stickerOverlayContainer = document.getElementById('sticker-overlay-container');

        let bucketMode = false;
        let activeSticker = null;
        let activePaletteSticker = null;
        let selectedColor = null;
        let isRestoring = false;
        let redoStack = [];

        let initialX, initialY, offsetX, offsetY;
        let initialTouchDistance = 0;
        let initialStickerWidth = 0;
        let initialStickerHeight = 0;

        let initialCenter = {
            x: 0,
            y: 0
        };
        let firstStickerAdded = false;

       const colors = [
    // Skin tones
    '#8d5524', '#c68642', '#e0ac69', '#f1c27d', '#ffdbac',

    // Reds
    '#FF0000', '#FF6347', '#D2691E', '#CD5C5C', '#800020', // burgundy added

    // Oranges & Yellows
    '#FFA500', '#FF8C00', '#FFD700', '#FFFF00', '#FFC04C', '#a67c00', 
    '#FF7F50', // coral
    '#DAA520', // goldenrod
    '#C2B280', // sand beige

    // Greens
    '#008000', '#3CB371', '#9ACD32', '#ADFF2F',
    '#013220', // deep forest green
    '#808000', // olive green

    // Blues
    '#0000FF', '#4169E1', '#1E90FF', '#87CEFA',
    '#000080', // navy
    '#008080', // teal
    '#40E0D0', // turquoise

    // Purples
    '#800080', '#4B0082', '#BA55D3', '#DA70D6',

    // Pinks & Browns
    '#FFC0CB', '#FF69B4', '#FA8072', '#A52A2A', '#8B4513',

    // Grays & Neutrals
    '#C0C0C0', '#808080', 
    '#A9A9A9', // dark gray / stone gray

    // Brights
    '#ff71ce', '#01cdfe', '#05ffa1', '#b967ff', '#fffb96',

    // Pastels
    '#ffb3ba', '#ffdfba', '#ffffba', '#baffc9', '#bae1ff',
    '#ffdef2', '#f2e2ff', '#e2eeff', '#ddfffc', '#ffffe3'
];

function getStickerPrice(count) {
    for (let tier of pricingTiers) {
        if (count <= tier.max) return tier.price;
    }
    return 0;
}

function updateFolderTotalPrice() {
    const priceSpan = document.getElementById("folder-price-value");
    if (!priceSpan) return;

    let total = 0;
    folderUrls.forEach((url, index) => {
        total += getStickerPrice(index + 1);
    });

    priceSpan.textContent = total.toFixed(2);
}

function showPriceNotification(price) {
    priceNotification.textContent = `+ $${price.toFixed(2)}`;
    priceNotification.classList.remove('hidden');
    priceNotification.classList.add('show');

    // Hide the notification after a few seconds
    setTimeout(() => {
        priceNotification.classList.remove('show');
        // You can add a slight delay before re-adding hidden for a smooth fade-out
        setTimeout(() => {
            priceNotification.classList.add('hidden');
        }, 500);
    }, 2000); // Display for 2 seconds
}
     

function isInsideFolder(x, y) {
    const rect = folder.getBoundingClientRect();
    return (
        x >= rect.left &&
        x <= rect.right &&
        y >= rect.top &&
        y <= rect.bottom
    );
}

window.addEventListener("message", (event) => {
    if (event.data.type === "saveSuccess") {
        // Hide loading screen
        document.getElementById("loading-popup").classList.add("hidden");

        const count = event.data.urlAmount || 0;
        const uuid = event.data.uuid || "N/A";

        // Store UUID and determine redirect URL
        currentUuid = uuid;
        currentRedirectUrl = redirectUrls[count] || redirectUrls[redirectUrls.length - 1];

        // Update success message
        document.getElementById("success-message").textContent =
            `Saved ${count} stickers successfully!`;

        // Show UUID container
        const uuidContainer = document.getElementById("uuid-container");
        const uuidText = document.getElementById("uuid-text");
        uuidText.textContent = uuid;
        uuidContainer.classList.remove("hidden");

        // Show success popup
        document.getElementById("success-popup").classList.remove("hidden");
    }

    if (event.data.type === "saveError") {
        document.getElementById("loading-popup").classList.add("hidden");
        alert("‚ùå Something went wrong: " + event.data.error);
    }
});

document.getElementById("go-to-url-btn").addEventListener("click", () => {
    if (currentRedirectUrl) {
        window.open(currentRedirectUrl, "_blank");
    }
});

document.getElementById("copy-uuid-btn").addEventListener("click", () => {
    const uuid = document.getElementById("uuid-text").textContent;

    // Create a temporary input
    const tempInput = document.createElement("input");
    tempInput.value = uuid;
    document.body.appendChild(tempInput);

    tempInput.select();
    tempInput.setSelectionRange(0, 99999); // For mobile

    try {
        const success = document.execCommand("copy");
        if (success) {
            alert(`UUID copied: ${uuid}`);
        } else {
            alert("Failed to copy UUID");
        }
    } catch (err) {
        alert("Failed to copy UUID: " + err);
    }

    document.body.removeChild(tempInput);
});



// Cancel hides popup
cancelBtn.addEventListener("click", () => {
    popup.classList.add("hidden");
});

function showSuccessPopup() {
    document.getElementById("success-popup").classList.remove("hidden");
}

document.getElementById("success-ok-btn").addEventListener("click", () => {
    document.getElementById("success-popup").classList.add("hidden");
});

sendBtn.addEventListener("click", () => {

    // ‚úÖ Only trigger save here
    window.parent.postMessage({
        type: "saveStickers",
        urls: folderUrls
    }, "*");
});



// --- Desktop Drag & Drop ---
folder.addEventListener('dragover', (e) => {
    e.preventDefault();
    if (folderUrls.length < MAX_FOLDER_IMAGES) {
        folder.classList.add('drag-over');
    }
});

folder.addEventListener('dragleave', () => {
    folder.classList.remove('drag-over');
});

folder.addEventListener("drop", (e) => {
    e.preventDefault();
    folder.classList.remove("drag-over");
    if (folderUrls.length >= MAX_FOLDER_IMAGES) {
        updateFolderUI();
        console.warn("üö´ Folder limit reached");
        return;
    }
    const jsonData = e.dataTransfer.getData("application/json");
    if (jsonData) {
        try {
            const { url } = JSON.parse(jsonData);
            addToFolder(url);
        } catch (err) {
            console.error("Invalid JSON drop", err);
        }
        return;
    }
    const stickerDivId = e.dataTransfer.getData("text/plain");
    if (stickerDivId) {
        const stickerToMove = document.getElementById(stickerDivId);
        if (stickerToMove && stickerToMove.classList.contains("sticker")) {
            const stickerUrl = stickerToMove.querySelector("img").src;
            addToFolder(stickerUrl, stickerToMove);
        }
    }
});


function addToFolder(stickerUrl, stickerEl) {
    if (stickerEl) {
        stickerEl.remove();
    }

    // Add to cart array
    folderUrls.push(stickerUrl);

    // Calculate price for the sticker just added
    const newStickerCount = folderUrls.length;
    const addedPrice = getStickerPrice(newStickerCount);

    // Update cart UI
    folderCount.textContent = `${folderUrls.length}`;
    updateFolderUI();

    // Show floating price notification
    showPriceNotification(addedPrice);

    // Update total price in folder overlay
    updateFolderTotalPrice();

    // Save state including cart for undo/redo
    saveState();
}


function renderFolderOverlay() {
    folderOverlay.innerHTML = "";
    document.querySelector(".controls").classList.add("disabled");

    // --- HEADER (sticky) ---
    const header = document.createElement("div");
    header.className = "overlay-header";
    header.style.position = "sticky";
    header.style.top = "0";
    header.style.background = "white";
    header.style.zIndex = "5";
    header.style.display = "flex";
    header.style.alignItems = "center";
    header.style.justifyContent = "space-between";
    header.style.padding = "10px";

  // Checkout button (left) as cart icon
const checkoutBtn = document.createElement("button");
checkoutBtn.className = "overlay-checkout";
checkoutBtn.disabled = folderUrls.length === 0;
checkoutBtn.style.background = "none";
checkoutBtn.style.border = "none";
checkoutBtn.style.cursor = "pointer";
checkoutBtn.style.padding = "0";

// Add a cart icon (SVG)
checkoutBtn.innerHTML = `
   <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 24 24" fill="none" 
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="cart-icon lucide-shopping-cart">
      <circle cx="9" cy="21" r="1" />
      <circle cx="20" cy="21" r="1" />
      <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6" />
    </svg>
`;

checkoutBtn.addEventListener("click", () => {
    if (!folderUrls.length) return;

    // Show loading screen
    document.getElementById("loading-popup").classList.remove("hidden");

    // Send URLs to Wix backend via postMessage
    window.parent.postMessage({
        type: "saveStickers",
        urls: folderUrls
    }, "*");
});

// Listen for the backend response (from wix code)
window.addEventListener("message", async (event) => {
    if (event.data.type === "saveSuccess") {
        document.getElementById("loading-popup").classList.add("hidden");

        const uuid = event.data.uuid;
        const count = folderUrls.length;

        console.log("‚úÖ Stickers saved with UUID:", uuid);

        // Populate the hidden Wix checkout field
        $w("#sticker_ids").value = uuid;

        // Update success popup
        document.getElementById("success-message").textContent =
            `Saved ${count} stickers successfully! UUID: ${uuid}`;
        document.getElementById("uuid-text").textContent = uuid;
        document.getElementById("uuid-container").classList.remove("hidden");
        document.getElementById("success-popup").classList.remove("hidden");
    }

    if (event.data.type === "saveError") {
        document.getElementById("loading-popup").classList.add("hidden");
        alert("‚ùå Something went wrong: " + event.data.error);
    }
});

    // Total price (center)
    const priceDiv = document.createElement("div");
    priceDiv.style.flex = "1";
    priceDiv.style.textAlign = "center";
    priceDiv.innerHTML = `Total: $<span id="folder-price-value">0.00</span>`;

    // Close button (right)
    const closeBtn = document.createElement("button");
    closeBtn.className = "overlay-close";
    closeBtn.textContent = "√ó";
    closeBtn.addEventListener("click", () => {
        folderOverlay.style.display = "none";
        document.querySelector(".controls").classList.remove("disabled");
        enablePaletteStickers();
    });

    header.appendChild(checkoutBtn);
    header.appendChild(priceDiv);
    header.appendChild(closeBtn);
    folderOverlay.appendChild(header);

   

    // --- Stickers container ---
    const stickersContainer = document.createElement("div");
    stickersContainer.style.overflowY = "auto";
    stickersContainer.style.flex = "1";
    stickersContainer.style.display = "grid";
    stickersContainer.style.gridTemplateColumns = "repeat(auto-fill, minmax(100px, 1fr))";
    stickersContainer.style.gap = "12px";
    stickersContainer.style.marginTop = "10px";
    stickersContainer.style.paddingBottom = "10px";
    stickersContainer.style.maxHeight = "calc(100% - 70px)"; // leave space for header + separator

    if (!folderUrls.length) {
        const counterMsg = document.createElement("p");
    counterMsg.className = "empty-counter";
    counterMsg.textContent = `0 / 25`;

    // Center it in the container
    stickersContainer.style.display = "flex";
    stickersContainer.style.justifyContent = "center";
    stickersContainer.style.alignItems = "center";
    stickersContainer.style.height = "100%";

    // Style the text
    counterMsg.style.fontSize = "2rem";       // bigger font
    counterMsg.style.color = "#cccccc";       // light grey
    counterMsg.style.fontWeight = "bold";

    stickersContainer.appendChild(counterMsg);

    } else {
        folderUrls.forEach((url, index) => {
            const wrapper = document.createElement("div");
            wrapper.className = "overlay-sticker-wrapper";

            const img = document.createElement("img");
            img.src = url;
            img.className = "overlay-sticker";

            // ‚úÖ Prevent long-press download / context menu
img.addEventListener("contextmenu", (e) => e.preventDefault());
img.addEventListener("touchstart", (e) => {
    // Prevent long press from triggering save dialog
    e.preventDefault();
});
img.addEventListener("mousedown", (e) => e.preventDefault());

            const delBtn = document.createElement("button");
            delBtn.textContent = "‚Äì";
            delBtn.className = "delete-sticker-btn";
            delBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                folderUrls.splice(index, 1);
                updateFolderUI();
                renderFolderOverlay();
                updateFolderTotalPrice();
            });

            wrapper.appendChild(img);
            wrapper.appendChild(delBtn);
            stickersContainer.appendChild(wrapper);
        });
    }

    folderOverlay.appendChild(stickersContainer);

    // Show overlay
    folderOverlay.style.display = "flex";
    folderOverlay.style.flexDirection = "column";
    folderOverlay.style.height = "80%";
    folderOverlay.style.width = "80%";

    updateFolderTotalPrice();
}




folderOverlay.addEventListener("dragover", (e) => {
    e.preventDefault();
});

folderOverlay.addEventListener("drop", (e) => {
    e.preventDefault();
    let jsonData = e.dataTransfer.getData("application/json");
    if (jsonData) {
        try {
            const { url } = JSON.parse(jsonData);
            if (url && !folderUrls.includes(url)) {
                folderUrls.push(url);
                updateFolderUI();
                renderFolderOverlay();
            }
            return;
        } catch (err) {
            console.error("Invalid JSON drop into folder", err);
        }
    }
    const stickerId = e.dataTransfer.getData("text/plain");
    if (stickerId) {
        const draggedEl = document.getElementById(stickerId);
        if (draggedEl && draggedEl.src && !folderUrls.includes(draggedEl.src)) {
            folderUrls.push(draggedEl.src);
            updateFolderUI();
            renderFolderOverlay();
        }
    }
});

// --- CLICK TO OPEN OVERLAY ---
folder.addEventListener("click", () => {
    renderFolderOverlay();
});

function disablePaletteStickers() {
    document.querySelector("#sticker-palette-container").classList.add("disabled");
}

function enablePaletteStickers() {
    document.querySelector("#sticker-palette-container").classList.remove("disabled");
}

function updateFolderUI() {
    folderCount.textContent = `${folderUrls.length}`;
    if (folderUrls.length >= MAX_FOLDER_IMAGES) {
        folder.classList.add("full");
    } else {
        folder.classList.remove("full");
    }
}









        function setBucketMode(enabled) {
            bucketMode = enabled;
            if (bucketMode) {
                document.body.classList.add('bucket-active');
                canvas.style.cursor = 'crosshair';
                document.querySelectorAll('.color-swatch').forEach(swatch => {
                    swatch.draggable = false;
                });
            } else {
                document.body.classList.remove('bucket-active');
                canvas.style.cursor = 'default';
                document.querySelectorAll('.color-swatch').forEach(swatch => {
                    swatch.draggable = true;
                });
            }
        }

function saveState() {
    if (isRestoring) return;
    const stickersOnCanvas = document.querySelectorAll('#canvas-container .sticker');
    const currentState = {
        stickers: [],
        folder: [...folderUrls] // ‚úÖ track cart contents too
    };

    stickersOnCanvas.forEach(sticker => {
        const stickerImg = sticker.querySelector('img');
        if (stickerImg) {
            currentState.stickers.push({
                url: stickerImg.src,
                x: sticker.offsetLeft,
                y: sticker.offsetTop,
                width: sticker.offsetWidth,
                height: sticker.offsetHeight,
                locked: sticker.classList.contains('locked'),
                groupName: sticker.dataset.group
            });
        }
    });

    const prevState = history[history.length - 1];
    if (JSON.stringify(prevState) !== JSON.stringify(currentState)) {
        history.push(currentState);
    }

    redoStack = [];
    updateUndoRedoButtons();
}


function loadState(state) {
    isRestoring = true;

    const stickersLayer = document.getElementById('stickers-layer');
    stickersLayer.innerHTML = '';

    const canvasWidth = canvas.offsetWidth;
    const canvasHeight = canvas.offsetHeight;

    state.stickers.forEach(data => {
        const newSticker = addSticker(
            data.url,
            data.x,
            data.y,
            data.width,
            data.height,
            { suppressSave: true, group: data.groupName }
        );
        if (data.locked) newSticker.classList.add('locked');

        // If this sticker was previously in the cart (folder) but now back on canvas:
        if (!state.folder.includes(data.url)) {
            // Place it in center
            newSticker.style.left = `${(canvasWidth - data.width) / 2}px`;
            newSticker.style.top = `${(canvasHeight - data.height) / 2}px`;
        }

        stickersLayer.appendChild(newSticker);
    });

    // Restore folder/cart
    folderUrls = [...state.folder];
    folderCount.textContent = folderUrls.length;
    updateFolderUI();

    isRestoring = false;
    updateUndoRedoButtons();
}





        function deselectAllStickers() {
            document.querySelectorAll('.sticker').forEach(s => {
                s.classList.remove('selected');
            });
        }

        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

   
function getRandomStickerUrlFromGroups() {
    if (!stickerGroups || stickerGroups.length === 0) return null;

    const firstStickers = stickerGroups
        .filter(group => group.urls && group.urls.length > 0)
        .map(group => ({ url: group.urls[0], group: group.name }));

    if (firstStickers.length === 0) return null;

    const randomIndex = Math.floor(Math.random() * firstStickers.length);
    return firstStickers[randomIndex]; // ‚úÖ now always first sticker of group
}


spinBtn.addEventListener("click", async () => {
    console.log("üé∞ Spin button clicked");

    const allStickers = document.querySelectorAll('.sticker');
    let targetStickerDiv = null;

    if (allStickers.length === 0) {
        console.log("‚ÑπÔ∏è Canvas is empty, adding a new sticker.");
        const randomStickerData = getRandomStickerUrlFromGroups();
        if (randomStickerData) {
            addSticker(randomStickerData.url, 120, 120, 120, 120, { 
                group: randomStickerData.group, 
                letter: randomStickerData.letter 
            });
            targetStickerDiv = document.querySelector('.sticker');
        }
    } else {
        targetStickerDiv = document.querySelector('.sticker:not(.locked)');
        
        if (!targetStickerDiv) {
            console.log("‚ÑπÔ∏è All stickers are locked, adding a new one.");
            const randomStickerData = getRandomStickerUrlFromGroups();
            if (randomStickerData) {
                addSticker(randomStickerData.url, 120, 120, 120, 120, { 
                    group: randomStickerData.group, 
                    letter: randomStickerData.letter 
                });
                targetStickerDiv = document.querySelector('.sticker:not(.locked)');
            }
        }
    }
    
    if (!targetStickerDiv) {
        console.warn("‚ö†Ô∏è No unlocked sticker found. Aborting spin.");
        return;
    }
    
    // --- UPDATED LOGIC HERE ---
    const stickerPool = [];
    stickerGroups.forEach(group => {
        // Now, take the first URL from the `urls` array directly
        if (group.urls && group.urls.length > 0) {
            stickerPool.push({
                url: group.urls[0], // Access the first element of the array
                group: group.name
            });
        }
    });

    console.log(`‚è≥ Preloading a small subset of stickers (${stickerPool.length})...`);
    await preloadStickers(stickerPool.map(s => s.url));
    console.log("‚úÖ Preloading complete. Starting spin.");
    
    // --- END UPDATED LOGIC ---

    const stickerImg = targetStickerDiv.querySelector('img');
    const stickerSize = targetStickerDiv.offsetWidth;
    const canvasWidth = canvas.offsetWidth;
    const canvasHeight = canvas.offsetHeight;
    const centerX = (canvasWidth / 2) - (stickerSize / 2);
    const centerY = (canvasHeight / 2) - (stickerSize / 2);
    
    targetStickerDiv.style.left = `${centerX}px`;
    targetStickerDiv.style.top = `${centerY}px`;
    
    let spinCount = 0;
    const maxSpins = 15 + Math.floor(Math.random() * 10);
    const spinInterval = setInterval(() => {
        const randomIndex = Math.floor(Math.random() * stickerPool.length);
        const nextStickerData = stickerPool[randomIndex];

        if (nextStickerData) {
            stickerImg.src = nextStickerData.url;
            targetStickerDiv.dataset.group = nextStickerData.group;
        }

        spinCount++;
        if (spinCount >= maxSpins) {
            clearInterval(spinInterval);
            targetStickerDiv.classList.add('pulse-effect');
            saveState();
        }
    }, 100);
});

// A function to preload images
function preloadStickers(urls) {
    const promises = urls.map(url => {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.src = url;
            img.onload = resolve;
            img.onerror = reject;
        });
    });
    return Promise.all(promises);
}


function addSticker(url, x, y, width = 200, height = 200, opts = {}) {
    const { suppressSave = false, group } = opts;

    const sticker = document.createElement('div');
    const groupName = group || 'default';
    sticker.dataset.group = groupName;
    console.log('[addSticker] Creating sticker with group:', groupName);

    sticker.classList.add('sticker');
    sticker.style.width = width + 'px';
    sticker.style.height = height + 'px';

    const stickerImg = document.createElement('img');
    stickerImg.crossOrigin = "Anonymous";
    stickerImg.src = url;
    stickerImg.draggable = false;
    stickerImg.classList.add("protected");
    sticker.appendChild(stickerImg);

    if (x !== undefined && y !== undefined) {
        sticker.style.left = `${x}px`;
        sticker.style.top = `${y}px`;
    }

    // --- Interaction and Event Listener Variables ---
    let activeSticker = null;
    let initialX, initialY, offsetX, offsetY;
    let initialPinchDistance = 0;
    let initialStickerWidth = 0;
    let initialStickerHeight = 0;
    let initialRect = null;

    // --- Interaction Buttons and Handlers ---
    const copyBtn = document.createElement('div');
    copyBtn.classList.add('copy-btn');
    copyBtn.innerHTML = `<svg class="copy-btn-icon" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
<line x1="12" y1="8" x2="12" y2="16" />
<line x1="8" y1="12" x2="16" y2="12" />
</svg>`;
    copyBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const stickerWidth = sticker.offsetWidth;
        const stickerHeight = sticker.offsetHeight;
        let newX = parseInt(sticker.style.left) + 10;
        let newY = parseInt(sticker.style.top) + 10;

        function isOverlapping(x, y) {
            const stickers = document.querySelectorAll('.sticker');
            return Array.from(stickers).some(s => {
                const sx = parseInt(s.style.left);
                const sy = parseInt(s.style.top);
                const sw = s.offsetWidth;
                const sh = s.offsetHeight;
                return !(x + stickerWidth < sx || x > sx + sw || y + stickerHeight < sy || y > sy + sh);
            });
        }
        const step = 10;
        let attempts = 0;
        while (isOverlapping(newX, newY) && attempts < 100) {
            newX += step;
            newY += step;
            if (newX + stickerWidth > canvas.offsetWidth) newX = step;
            if (newY + stickerHeight > canvas.offsetHeight) newY = step;
            attempts++;
        }
        saveState();
addSticker(
    stickerImg.src,
    newX,
    newY,
    sticker.offsetWidth,
    sticker.offsetHeight,
    { group: sticker.dataset.group }
);   
 });

    const deleteBtn = document.createElement('div');
    deleteBtn.classList.add('delete-btn');
    deleteBtn.innerHTML = `<svg class="delete-btn-icon" viewBox="0 0 24 24">
<line x1="5" y1="12" x2="19" y2="12" stroke="white" stroke-width="1" />
</svg>`;
    deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        saveState();
        sticker.remove();
    });

    const lockBtn = document.createElement('div');
    lockBtn.classList.add('lock-btn');
    lockBtn.innerHTML = `<svg class="lock-btn-icon" data-lucide="lock" viewBox="0 0 24 24">
<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
<path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
</svg>`;
lockBtn.addEventListener('click', (e) => {
    // Prevent the click event from bubbling up and affecting the canvas or sticker
    e.stopPropagation();

    // Find the closest parent element with the class 'sticker'
    const sticker = e.target.closest('.sticker');

    if (sticker) {
        // This line toggles the 'locked' class on the sticker.
        sticker.classList.toggle('locked');
        
        // This is a good practice to ensure the sticker is no longer "selected"
        // if it was, which helps manage button visibility after the lock/unlock action.
        sticker.classList.remove('selected');

        // Save the state of the canvas after the change
        saveState();
    }
});

    sticker.appendChild(deleteBtn);
    sticker.appendChild(copyBtn);
    sticker.appendChild(lockBtn);

const groupBtn = document.createElement('div');
groupBtn.classList.add('sticker-btn', 'group-btn');
groupBtn.innerHTML = `
<svg class="group-btn-icon" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
  <path d="M4 6h16M4 12h16M4 18h16"/>
</svg>`;


// On click, open overlay with this sticker's group
groupBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    const stickerGroup = sticker.dataset.group;
    const group = stickerGroups.find(g => g.name === stickerGroup);
    if (group) {
        // Pass both the URLs and the group name
        showStickerOverlay(group.urls, group.name); 
    }
});

sticker.appendChild(groupBtn);

   function startInteraction(e) {
 if (e.target.closest('.delete-btn, .copy-btn, .lock-btn, .group-btn')) return;

    if (bucketMode && (!e.touches || e.touches.length < 2)) {
        return;
    }

    activeSticker = sticker;
    deselectAllStickers();
    sticker.classList.add('selected');
    saveState();

    if (e.touches && e.touches.length === 2) {
        // Two-finger gesture (resizing)
        e.preventDefault(); 
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
        initialStickerWidth = sticker.offsetWidth;
        initialStickerHeight = sticker.offsetHeight;
        initialRect = sticker.getBoundingClientRect();
        
        document.addEventListener('touchmove', handleMove, { passive: false });
    } else if (e.touches && e.touches.length === 1) {
        // Single-finger gesture (dragging)
        const touch = e.touches[0];
        initialX = touch.clientX;
        initialY = touch.clientY;
        offsetX = sticker.offsetLeft;
        offsetY = sticker.offsetTop;
        
        document.addEventListener('touchmove', handleMove, { passive: false });
    } else {
        // Mouse interaction (dragging)
        initialX = e.clientX;
        initialY = e.clientY;
        offsetX = sticker.offsetLeft;
        offsetY = sticker.offsetTop;
        
        document.addEventListener('mousemove', handleMove);
    }

    document.addEventListener('mouseup', handleEnd);
    document.addEventListener('touchend', handleEnd);
}

 function handleMove(e) {
    if (!activeSticker) return;

    if (e.touches && e.touches.length === 2) {
        e.preventDefault();
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const currentPinchDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
        );
        const scaleFactor = currentPinchDistance / initialPinchDistance;
        const newWidth = initialStickerWidth * scaleFactor;
        const newHeight = initialStickerHeight * scaleFactor;
        const minSize = 30;

        if (newWidth >= minSize) {
            const isShrinking = newWidth < initialStickerWidth;
            const canvasRect = canvas.getBoundingClientRect();
            let adjustedLeft = initialRect.left;
            let adjustedTop = initialRect.top;

            if (isShrinking) {
                const widthDiff = initialStickerWidth - newWidth;
                const heightDiff = initialStickerHeight - newHeight;
                adjustedLeft = initialRect.left + widthDiff / 2;
                adjustedTop = initialRect.top + heightDiff / 2;

                if (adjustedLeft < canvasRect.left) adjustedLeft = canvasRect.left;
                if (adjustedTop < canvasRect.top) adjustedTop = canvasRect.top;
                if (adjustedLeft + newWidth > canvasRect.right)
                    adjustedLeft = canvasRect.right - newWidth;
                if (adjustedTop + newHeight > canvasRect.bottom)
                    adjustedTop = canvasRect.bottom - newHeight;
            } else {
                const widthDiff = newWidth - initialStickerWidth;
                const heightDiff = newHeight - initialStickerHeight;
                adjustedLeft = initialRect.left - widthDiff / 2;
                adjustedTop = initialRect.top - heightDiff / 2;
            }

            activeSticker.style.width = `${newWidth}px`;
            activeSticker.style.height = `${newHeight}px`;
            activeSticker.style.left = `${adjustedLeft - canvasRect.left}px`;
            activeSticker.style.top = `${adjustedTop - canvasRect.top}px`;
        }
    } else if (!bucketMode && (!e.touches || e.touches.length === 1)) {
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const dx = clientX - initialX;
        const dy = clientY - initialY;
        activeSticker.style.left = `${offsetX + dx}px`;
        activeSticker.style.top = `${offsetY + dy}px`;
    }

    if (activeSticker) {
        const folderRect = folder.getBoundingClientRect();
        const stickerRect = activeSticker.getBoundingClientRect();
        const isOverFolder =
            stickerRect.right > folderRect.left &&
            stickerRect.left < folderRect.right &&
            stickerRect.bottom > folderRect.top &&
            stickerRect.top < folderRect.bottom;

        // ‚úÖ Only glow if folder not full
        if (isOverFolder && folderUrls.length < MAX_FOLDER_IMAGES) {
            folder.classList.add("drag-over");
        } else {
            folder.classList.remove("drag-over");
        }
    }
}

 function handleEnd() {
    // Remove event listeners
    document.removeEventListener("mousemove", handleMove);
    document.removeEventListener("mouseup", handleEnd);
    document.removeEventListener("touchmove", handleMove);
    document.removeEventListener("touchend", handleEnd);

    if (activeSticker) {
        const folderRect = folder.getBoundingClientRect();
        const stickerRect = activeSticker.getBoundingClientRect();
        const isOverFolder =
            stickerRect.right > folderRect.left &&
            stickerRect.left < folderRect.right &&
            stickerRect.bottom > folderRect.top &&
            stickerRect.top < folderRect.bottom;

        if (isOverFolder) {

            

            if (folderUrls.length >= MAX_FOLDER_IMAGES) {
                folder.classList.add("full", "shake");
                setTimeout(() => folder.classList.remove("full", "shake"), 600);
                activeSticker.style.transition = "transform 0.3s ease, opacity 0.3s ease";
                activeSticker.style.transform = "translate(0,0) scale(1)";
                activeSticker.style.opacity = "1";
            } else {
                folder.classList.add("success", "pulse");
                setTimeout(() => folder.classList.remove("success", "pulse"), 500);
                const stickerUrl = activeSticker.querySelector("img").src;
                const dx =
                    folderRect.left + folderRect.width / 2 -
                    (stickerRect.left + stickerRect.width / 2);
                const dy =
                    folderRect.top + folderRect.height / 2 -
                    (stickerRect.top + stickerRect.height / 2);
                activeSticker.style.transition =
                    "transform 0.4s ease, opacity 0.4s ease";
                activeSticker.style.transform = `translate(${dx}px, ${dy}px) scale(0.1)`;
                activeSticker.style.opacity = "0";

                // This is the fix: move the reset logic inside the timeout
                setTimeout(() => {
                    addToFolder(stickerUrl, activeSticker);
                    if (activeSticker && activeSticker.parentNode === canvas) {
                        canvas.removeChild(activeSticker);
                    }
                    // Reset activeSticker here after removal
                    activeSticker = null; 
                }, 400);
            }
        } else {
            
          
           
            activeSticker.style.opacity = "1";
        }
        activeSticker.classList.remove("selected");
    }

    // Move this logic outside the `if (activeSticker)` block
    initialRect = null;
    initialTouchDistance = 0;
    initialStickerWidth = 0;
    initialStickerHeight = 0;
    saveState();
}

    // --- Event Listeners ---
    sticker.addEventListener('mousedown', startInteraction);
    sticker.addEventListener('touchstart', startInteraction);

    sticker.addEventListener('wheel', (e) => {
        // Desktop Resizing Logic
        e.preventDefault();
        saveState();
        const parent = sticker;
        const delta = Math.sign(e.deltaY);
        const initialRect = parent.getBoundingClientRect();
        const initialWidth = initialRect.width;
        const initialHeight = initialRect.height;
        const newSize = initialWidth + (delta * 10);
        const minSize = 30;

        if (newSize >= minSize) {
            const newHeight = newSize / (initialWidth / initialHeight);
            const canvasRect = canvas.getBoundingClientRect();
            let adjustedLeft = initialRect.left;
            let adjustedTop = initialRect.top;
            const isShrinking = newSize < initialWidth;

            if (isShrinking) {
                adjustedLeft = initialRect.left + (initialWidth / 2) - (newSize / 2);
                adjustedTop = initialRect.top + (initialHeight / 2) - (newHeight / 2);

                if (adjustedLeft < canvasRect.left) adjustedLeft = canvasRect.left;
                if (adjustedTop < canvasRect.top) adjustedTop = canvasRect.top;
                if (adjustedLeft + newSize > canvasRect.right) adjustedLeft = canvasRect.right - newSize;
                if (adjustedTop + newHeight > canvasRect.bottom) adjustedTop = canvasRect.bottom - newHeight;
            } else {
                adjustedLeft = initialRect.left - (newSize - initialWidth) / 2;
                adjustedTop = initialRect.top - (newHeight - initialHeight) / 2;
            }

            parent.style.width = `${newSize}px`;
            parent.style.height = `${newHeight}px`;
            parent.style.left = `${adjustedLeft - canvasRect.left}px`;
            parent.style.top = `${adjustedTop - canvasRect.top}px`;
            saveState();
        }
    });

    stickerImg.addEventListener('click', (e) => {
        if (bucketMode && selectedColor) {
            e.stopPropagation();
            const rect = sticker.getBoundingClientRect();
            const clickX = Math.floor((e.clientX - rect.left) * (stickerImg.naturalWidth / rect.width));
            const clickY = Math.floor((e.clientY - rect.top) * (stickerImg.naturalHeight / rect.height));
            recolorSticker(stickerImg, selectedColor, clickX, clickY);
        }
    });

    const updateButtonSizes = () => {
        const btnSize = sticker.offsetWidth * 0.2;
        [deleteBtn, copyBtn, lockBtn, groupBtn].forEach(btn => {
            btn.style.width = btnSize + 'px';
            btn.style.height = btnSize + 'px';
        });
        deleteBtn.style.top = deleteBtn.style.right = `${btnSize * 0.25}px`;
        copyBtn.style.top = copyBtn.style.left = `${btnSize * 0.25}px`;
         lockBtn.style.bottom = lockBtn.style.left = `${btnSize * 0.25}px`;
        groupBtn.style.bottom = groupBtn.style.right = `${btnSize * 0.25}px`;
    };

    updateButtonSizes();
    const observer = new ResizeObserver(updateButtonSizes);
    observer.observe(sticker);
    canvas.appendChild(sticker);

    if (window.lucide) {
        lucide.createIcons();
    }

    if (!suppressSave && !isRestoring) {
        saveState();
    }

    return sticker;
}

     
    
        function hexToRgb(hex) {
            hex = hex.replace(/^#/, "");
            const bigint = parseInt(hex, 16);
            return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
        }

  
        function recolorSticker(stickerImg, fillColor, clickX, clickY) {
    const canvasEl = document.createElement("canvas");
    const ctx = canvasEl.getContext("2d", { willReadFrequently: true });
    canvasEl.width = stickerImg.naturalWidth;
    canvasEl.height = stickerImg.naturalHeight;
    ctx.drawImage(stickerImg, 0, 0);

    const imgData = ctx.getImageData(0, 0, canvasEl.width, canvasEl.height);
    const data = imgData.data;
    const { width, height } = canvasEl;


    // --- Inlined helper functions for performance ---
    const blackThreshold = 30;
    const tolerance = 30;

    const startIndex = (clickY * width + clickX) * 4;
    const targetColor = [
        data[startIndex],
        data[startIndex + 1],
        data[startIndex + 2],
        data[startIndex + 3]
    ];
    
    // Early exit if the clicked pixel is a border
    if (targetColor[3] > 0 && targetColor[0] < blackThreshold && targetColor[1] < blackThreshold && targetColor[2] < blackThreshold) {
        return; 
    }

    const visited = new Uint8Array(width * height);
    let touchesEdge = false;

    const stack = [[clickX, clickY]];

    // --- OPTIMIZATION 1: Run synchronously in a single loop ---
    while (stack.length) {
        let [x, y] = stack.pop();

        let left = x;
        while (left >= 0 && !visited[y * width + left] && isFillable(left, y)) {
            left--;
        }
        left++;

        let right = x;
        while (right < width && !visited[y * width + right] && isFillable(right, y)) {
            right++;
        }
        right--;

        // Fill the span
        for (let i = left; i <= right; i++) {
            const idx = y * width + i;
            visited[idx] = 1;
            const dataIndex = idx * 4;

            if (isEraser) {
                data[dataIndex + 3] = 0;
            } else {
                data[dataIndex] = r;
                data[dataIndex + 1] = g;
                data[dataIndex + 2] = b;
                data[dataIndex + 3] = 255;
            }

            if (i === 0 || i === width - 1 || y === 0 || y === height - 1) {
                touchesEdge = true;
            }
        }

        // --- OPTIMIZATION 2: Efficiently find and add new scanlines ---
        scan(y - 1, left, right); // Scan row above
        scan(y + 1, left, right); // Scan row below
    }

    // Helper to check if a pixel should be filled
    function isFillable(px, py) {
        if (px < 0 || px >= width || py < 0 || py >= height) return false;
        
        const idx = (py * width + px) * 4;
        const R = data[idx];
        const G = data[idx + 1];
        const B = data[idx + 2];
        const A = data[idx + 3];

        // Check if it's a border pixel
        if (A > 0 && R < blackThreshold && G < blackThreshold && B < blackThreshold) {
            return false;
        }

        // Check if it matches the target color
        return (
            Math.abs(R - targetColor[0]) <= tolerance &&
            Math.abs(G - targetColor[1]) <= tolerance &&
            Math.abs(B - targetColor[2]) <= tolerance &&
            Math.abs(A - targetColor[3]) <= tolerance
        );
    }
    
    // Helper to find new spans to add to the stack
    function scan(y, lx, rx) {
        if (y < 0 || y >= height) return;
        for (let x = lx; x <= rx; x++) {
            if (!visited[y * width + x] && isFillable(x, y)) {
                // We found a new, uncolored span. Push it and skip the rest of this span.
                stack.push([x, y]);
                // Fast-forward past the rest of this colored span
                while (x <= rx && isFillable(x, y)) {
                    x++;
                }
            }
        }
    }

    if (!touchesEdge) {
        ctx.putImageData(imgData, 0, 0);
        stickerImg.src = canvasEl.toDataURL();
       saveState(); 
    }
}


        function updateUndoRedoButtons() {
            undoBtn.disabled = history.length <= 1;
            redoBtn.disabled = redoStack.length === 0;
        }


        undoBtn.addEventListener('click', () => {
    if (history.length > 1) {
        const currentState = history.pop();
        redoStack.push(currentState);

        const previousState = history[history.length - 1];

        // ‚úÖ Remove all current stickers first
        const stickersLayer = document.getElementById('stickers-layer');
        stickersLayer.innerHTML = '';

        // ‚úÖ Load the previous state
        loadState(previousState);
    }
});

        redoBtn.addEventListener('click', () => {
            if (redoStack.length > 0) {
                const nextState = redoStack.pop();
                history.push(nextState);
                loadState(nextState);
                updateUndoRedoButtons();
            }
        });

function addOrReplaceSticker(newUrl, groupName = null) {
    const stickersLayer = document.getElementById('stickers-layer') || canvas;

    // Deselect any previously selected sticker
    const currentlySelected = stickersLayer.querySelector('.sticker.selected');
    if (currentlySelected) currentlySelected.classList.remove('selected');

    const unlockedSticker = stickersLayer.querySelector('.sticker:not(.locked)');
    const stickerSize = 120;
    const centerX = (canvas.offsetWidth / 2) - (stickerSize / 2);
    const centerY = (canvas.offsetHeight / 2) - (stickerSize / 2);

    if (unlockedSticker) {
        // ‚úÖ Replace image and properties without removing the element
        const stickerImg = unlockedSticker.querySelector('img');
        stickerImg.src = newUrl;
        unlockedSticker.style.width = `${stickerSize}px`;
        unlockedSticker.style.height = `${stickerSize}px`;
        unlockedSticker.style.left = `${centerX}px`;
        unlockedSticker.style.top = `${centerY}px`;

        if (groupName) unlockedSticker.dataset.group = groupName;
        else if (!unlockedSticker.dataset.group)
            unlockedSticker.dataset.group = stickerGroups[0]?.name || 'default';

        stickerImg.onload = () => {
            unlockedSticker.style.opacity = '1';
        };

    } else {
        const newGroup = groupName || stickerGroups[0]?.name || 'default';
        const newSticker = addSticker(newUrl, centerX, centerY, stickerSize, stickerSize, { group: newGroup });
        stickersLayer.appendChild(newSticker);
    }

    // ‚úÖ Save state only after the final sticker exists
    saveState();
}

addStickerBtn.addEventListener('click', () => {
    // Find a random group first
    const randomGroup = stickerGroups[Math.floor(Math.random() * stickerGroups.length)];
    // Find a random URL from that group
    const randomUrl = randomGroup.urls[Math.floor(Math.random() * randomGroup.urls.length)];

    // Pass both the URL AND the group name to the function
    addOrReplaceSticker(randomUrl, randomGroup.name);
});

newBtn.addEventListener('click', () => {
    // 1Ô∏è‚É£ Clear canvas stickers
    const stickers = canvas.querySelectorAll('.sticker');
    stickers.forEach(s => s.remove());

    // 2Ô∏è‚É£ Clear overlays
    const stickerOverlay = document.getElementById('sticker-overlay-container');
    if (stickerOverlay) stickerOverlay.innerHTML = '';

    const groupOverlay = document.getElementById('group-overlay-container');
    if (groupOverlay) groupOverlay.innerHTML = '';

    // 3Ô∏è‚É£ Clear cart overlay DOM
    const folderOverlay = document.getElementById('folder-overlay');
    if (folderOverlay) folderOverlay.innerHTML = '';

    // 4Ô∏è‚É£ Clear cart data
    folderUrls = [];

    // 5Ô∏è‚É£ Reset cart UI
    const folderCount = document.getElementById('folder-count');
    folderCount.textContent = '0';
    const folder = document.getElementById('folder');
    folder.classList.remove('full', 'success', 'shake');
    folder.style.display = 'flex';

    // 6Ô∏è‚É£ Clear floating price notification
    const priceNotification = document.getElementById('price-notification');
    priceNotification.classList.remove('show');
    priceNotification.classList.add('hidden');
    priceNotification.textContent = '';

    // 7Ô∏è‚É£ Save empty state for undo
    saveState();

    // 8Ô∏è‚É£ Reset flags
    firstStickerAdded = false;
});

window.addEventListener('load', () => {
    if (window.lucide) {
        lucide.createIcons();
    }
    updateCanvasDrop();
    const allStickers = document.querySelectorAll('.sticker');
    if (allStickers.length === 0) {
        const randomStickerData = getRandomStickerUrlFromGroups();
        if (randomStickerData) {
            // Pass the URL from the object to the function
            addOrReplaceSticker(randomStickerData.url, randomStickerData.group);
        }
    }
});

        let isDragging = false;
        let startX;
        let scrollLeft;
        let isSwiping = false;
        let initialTap = {
            clientX: 0
        };

        function addSwipeFunctionality() {
            const paletteContainer = document.querySelector('.color-palette-container');
            const palette = document.querySelector('.color-palette');

            const handleStart = (e) => {
                isDragging = true;
                startX = e.type.includes('mouse') ? e.pageX - paletteContainer.offsetLeft : e.touches[0].clientX;
                scrollLeft = paletteContainer.scrollLeft;
                initialTap.clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
            };

            const handleMove = (e) => {
                if (!isDragging) return;
                e.preventDefault();
                const x = e.type.includes('mouse') ? e.pageX - paletteContainer.offsetLeft : e.touches[0].clientX;
                const walk = (x - startX) * 1.5;
                paletteContainer.scrollLeft = scrollLeft - walk;
                if (Math.abs(e.clientX - initialTap.clientX) > 10) {
                    isSwiping = true;
                }
            };

            const handleEnd = () => {
                isDragging = false;
                setTimeout(() => {
                    isSwiping = false;
                }, 100);
            };

            [paletteContainer, palette].forEach(element => {
                element.addEventListener('mousedown', handleStart);
                element.addEventListener('mousemove', handleMove);
                element.addEventListener('mouseup', handleEnd);
                element.addEventListener('mouseleave', handleEnd);

                element.addEventListener('touchstart', handleStart);
                element.addEventListener('touchmove', handleMove, {
                    passive: false
                });
                element.addEventListener('touchend', handleEnd);
            });
        }

        function populateColorPalette() {
            colorPalette.innerHTML = '';
            colors.forEach(color => {
                const swatch = document.createElement('div');
                swatch.classList.add('color-swatch');
                swatch.style.backgroundColor = color;
                if (color === selectedColor) {
                    swatch.classList.add('active');
                }
                swatch.addEventListener('click', (e) => {
                    if (isSwiping) {
                        return;
                    }
                    const wasActive = swatch.classList.contains('active');

                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));

                    if (!wasActive) {
                        swatch.classList.add('active');
                        selectedColor = color;
                        setBucketMode(true);
                    } else {
                        selectedColor = null;
                        setBucketMode(false);
                    }
                });
                colorPalette.appendChild(swatch);
            });
        }

        function hideOverlays() {

            groupOverlayContainer.style.display = 'none';
            stickerOverlayContainer.style.display = 'none';
        }

// Function to show the initial group selection overlay
function showGroupOverlay() {
     hideOverlays();
    groupOverlayContainer.innerHTML = '';

    // Create the header with the title and close button
    const header = document.createElement('div');
    header.classList.add('overlay-header');
    
    const title = document.createElement('h2');
    title.textContent = "Sticker ausw√§hlen";
    title.classList.add('overlay-title');
    header.appendChild(title);
    
    // Create and append the close button to the header
    const closeBtn = document.createElement('button');
    closeBtn.textContent = '‚úï';
    closeBtn.classList.add('close-btn');
    closeBtn.addEventListener('click', hideOverlays);
    header.appendChild(closeBtn);
    
    // Create a separate container for the icons
    const iconsGrid = document.createElement('div');
    iconsGrid.classList.add('overlay-icons-grid');

      // Set grid styles directly in JavaScript
    iconsGrid.style.display = 'grid';
    iconsGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(40px, 1fr))';
    iconsGrid.style.gap = '10px';
    iconsGrid.style.padding = '10px';
    iconsGrid.style.overflowY = 'auto';

    // Append both the header and the icons grid to the main container
    groupOverlayContainer.appendChild(header);
    groupOverlayContainer.appendChild(iconsGrid);

    // Show the main container and give it a vertical layout
    groupOverlayContainer.style.display = 'flex';
    groupOverlayContainer.style.flexDirection = 'column';

    // ‚úÖ NEW: Load and add group icons one-by-one
    stickerGroups.forEach((group, index) => {
        const groupIcon = document.createElement('img');
        groupIcon.classList.add('overlay-icon');
        groupIcon.title = group.name;

        // Add a listener to wait for the image to load, then fade it in
        groupIcon.onload = () => {
            groupIcon.style.opacity = '1';
        };
        
        // Initially hide the icon to prevent a blank box
        groupIcon.style.opacity = '0'; 
        groupIcon.style.transition = 'opacity 0.5s ease-in-out';

        // Add contextmenu listener
        groupIcon.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Call showStickerOverlay directly
        groupIcon.addEventListener('click', () => {
            showStickerOverlay(group.urls, group.name);
        });
        
        // Append to the DOM before setting the src to trigger the load
        iconsGrid.appendChild(groupIcon);



        // Use a short delay before setting the src for each icon
        setTimeout(() => {
            if (group.urls && group.urls.length > 0) {
                groupIcon.src = group.urls[0];
            }
        }, index * 50); // 50ms delay for each icon
    });
}

// Ensure the main event listener is also not async
stickerPickerBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    if (groupOverlayContainer.style.display === 'grid') {
        hideOverlays();
    } else {
        showGroupOverlay();
    }
});



        function updateCanvasDrop() {
            const canvas = document.getElementById('canvas-container');
            canvas.removeEventListener('dragover', (e) => {
                e.preventDefault();
            });
            canvas.removeEventListener('drop', handleCanvasDrop);
            canvas.addEventListener('drop', handleCanvasDrop);
        }

        function handleCanvasDrop(e) {
            e.preventDefault();
            const data = e.dataTransfer.getData('application/json');
            if (data) {
                const {
                    url,
                    width
                } = JSON.parse(data);
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left - (width / 2);
                const y = e.clientY - rect.top - (width / 2);
                saveState();
                addSticker(url, x, y, width);
            }
        }

        let activeTouchSticker = null;
        let touchOffsetX = 0;
        let touchOffsetY = 0;

// This function is now responsible for opening the overlay and handling the loading effect.
function showStickerOverlay(urls, groupName) {
    hideOverlays();
    
    // Save the current scroll position before clearing
    const scrollPosition = stickerOverlayContainer.scrollTop;
    
    stickerOverlayContainer.innerHTML = '';
    
    // Create the header and content wrapper
    const header = document.createElement('div');
    header.classList.add('overlay-header');
    
    const title = document.createElement('h2');
    title.textContent = groupName;
    title.classList.add('overlay-title');
    header.appendChild(title);
    
    const closeBtn = document.createElement('button');
    closeBtn.textContent = '‚úï';
    closeBtn.classList.add('close-btn');
    closeBtn.addEventListener('click', hideOverlays);
    header.appendChild(closeBtn);
    
    const contentWrapper = document.createElement('div');
    contentWrapper.classList.add('overlay-stickers-grid');
    stickerOverlayContainer.appendChild(header);
    stickerOverlayContainer.appendChild(contentWrapper);
    
    // Show the container
    stickerOverlayContainer.style.display = 'flex';
    
    // Load and add stickers
    urls.forEach((url, index) => {
        const sticker = document.createElement('img');
        sticker.classList.add('overlay-sticker');
        sticker.draggable = true;
        sticker.dataset.url = url;
        
        sticker.style.opacity = '0';
        sticker.style.transition = 'opacity 0.5s ease-in-out';

        sticker.addEventListener('contextmenu', (e) => e.preventDefault());
        sticker.addEventListener('dragstart', (e) => {
            const stickerData = { url: url, width: 120 };
            e.dataTransfer.setData('application/json', JSON.stringify(stickerData));
        });
        
        sticker.addEventListener('click', () => {
            const group = stickerGroups.find(g => g.urls.includes(url));
            addOrReplaceSticker(url, group ? group.name : null);
            hideOverlays();
        });

        sticker.onload = () => {
            sticker.style.opacity = '1';
        };

        contentWrapper.appendChild(sticker);
        
        setTimeout(() => {
            sticker.src = url;
        }, index * 50);
    });
    
    // ‚úÖ The key fix: Set the scroll position after a short delay
    setTimeout(() => {
        stickerOverlayContainer.scrollTop = scrollPosition;
    }, 200); // 200ms delay to give the browser time to render all images
}
       

        document.addEventListener('click', (e) => {
            if (!groupOverlayContainer.contains(e.target) && !stickerOverlayContainer.contains(e.target) && !stickerPickerBtn.contains(e.target)) {
                hideOverlays();
            }
        });

        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            const data = e.dataTransfer.getData('application/json');
            if (data) {
                const {
                    url,
                    width
                } = JSON.parse(data);
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                saveState();
                addSticker(url, x, y, width);
            }
        });

        addSwipeFunctionality();
        saveState();
      
document.addEventListener("contextmenu", function(e) {
  if (e.target.tagName === "IMG" && e.target.classList.contains("protected")) {
    e.preventDefault();
  }
}, false);

        
    </script>
</body>
</html>
