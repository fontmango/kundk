<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sticker Canvas</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 1vh;
            box-sizing: border-box;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
             height: 100vh; /* Set the height to 100% of the viewport height */
    overflow-y: hidden; /* Hide vertical overflow */
        }

        #canvas-container {
            width: 90%;
            height: 500px;
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
            position: relative;
            margin-top: 10px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-radius: 16px;
            touch-action: none;
        }

        .sticker {
            position: absolute;
            height: auto;
            cursor: grab;
            user-select: none;
            transition: transform 0.1s ease-in-out;
            box-sizing: border-box;
            touch-action: none;
        }

        .sticker img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .sticker:active {
            cursor: grabbing;
            z-index: 100;
        }

        .sticker:focus {
            outline: none;
        }

        .sticker:hover > .delete-btn,
        .sticker:hover > .copy-btn,
        .sticker:hover > .group-btn,
        .sticker:hover > .resize-handle {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sticker.selected > .delete-btn,
        .sticker.selected > .copy-btn,
        .sticker.selected > .group-btn,
        .sticker.selected > .resize-handle {
            display: flex;
        }

        .group-btn {
    position: absolute;
    bottom: 5%;
    right: 5%;
    width: 20%;
    height: 20%;
    border-radius: 50%;
    background-color: #c2bebeff;
    color: white;
    display: none; /* show on hover/selected */
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 101;
    padding: 0;
    transition: transform 0.2s, background-color 0.2s;
}

.group-btn:hover {
    background-color: #2be7d8; /* match copy-btn hover color */
    transform: scale(1.1);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.group-btn-icon {
    width: 60%;
    height: 60%;
}

        .controls {
            margin-top: 10px;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .bucket-active .sticker {
            border: none !important;
            transition: none !important;
        }

        .bucket-active .sticker .delete-btn,
        .bucket-active .sticker .copy-btn,
        .bucket-active .sticker .group-btn ,
        .bucket-active .sticker .resize-handle {
            
            display: none !important;
        }

        .bucket-active .sticker:active,
        .bucket-active .sticker:hover {
            cursor: crosshair;
        }

        button {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: none;
            cursor: pointer;
            color: #333;
            transition: transform 0.2s, color 0.2s;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

        button:focus, button:active {
            outline: 0 !important;
            box-shadow: none !important;
        }

        button:hover {
            color: #000;
            transform: scale(1.1);
        }

        button.active {
            border-radius: 50%;
            transform: scale(1.05);
        }

        .icon {
            width: 1.4em;
            height: 1.4em;
            stroke: currentColor;
        }

        .color-palette-container {
            width: 100%;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
            touch-action: pan-y;
            align-items: center;
        
        }

        /* NEW WRAPPER ELEMENT FOR CENTERING */
.color-palette-wrapper {
    width: 100%;
    display: flex;
    justify-content: center;
}

        .color-palette-container::-webkit-scrollbar {
            display: none;
        }

        .color-palette {
            display: flex;
            flex-wrap: nowrap;
            gap: 8px;
            margin-top: 10px;
            margin-bottom: 5px;
            padding: 3px;
            width: max-content;
        }

        .color-swatch:hover {
            transform: scale(1.2);
        }

        .color-swatch {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.2s, border-color 0.2s;
            flex-shrink: 0;
            outline: 0 !important;
            box-shadow: none !important;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }


        .color-swatch.active {
            transform: scale(1.2);
            border-color: #000000;
        }

  #sticker-palette-container {
    width: 100%;
    margin-top: 20px;
    padding: 5px;
    background-color: #f8f8f8;
    border: 1px solid #ddd;
    border-radius: 8px;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);

    display: flex;
    flex-wrap: nowrap;      /* single row */
    overflow-x: auto;       /* horizontal scroll */
    overflow-y: hidden;

    align-items: center;    /* vertical centering */
    /* REMOVE or comment out the line below */
    /* justify-content: center; */
    gap: 10px;              /* space between items */
    scrollbar-width: thin;
}

#sticker-palette-container::-webkit-scrollbar {
    height: 8px;
}

#sticker-palette-container::-webkit-scrollbar-thumb {
    background: #bbb; 
    border-radius: 4px;
}

        .palette-sticker {
            width: 60px;
            height: 60px;
            object-fit: contain;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s, transform 0.2s;
        }

        .palette-sticker:hover {
            transform: scale(1.1);
        }
        
        /* --- MODIFIED CSS FOR OVERLAY --- */
        #overlay-container {
    position: fixed;
    top: 50%;
    left: 20px;  /* Anchors to the left edge with a 20px margin */
    transform: translateY(-50%); /* Vertically centers it */
    background-color: #ffffff;
    border: 1px solid #e0e0e0;
    border-radius: 12px;
    padding: 0;
    z-index: 200;
    box-shadow: 0 5px 25px rgba(0, 0, 0, 0.15);
    width: 90%;
    max-width: 400px; /* Adjusted max-width for a sleeker look on the side */
    
    display: flex;
    flex-direction: column;
}

.overlay-header {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 20px; /* Vertical padding is now controlled by height */
    border-bottom: 1px solid #e0e0e0;
    flex-shrink: 0;
    position: relative;
    height: 55px; /* Added a fixed height */
}

/* --- MODIFIED: Styles for the centered title --- */
.overlay-title {
    position: absolute; /* Allows for perfect centering */
    left: 50%;
    transform: translateX(-50%);
    margin: 0;
    font-size: 1.1rem;
    font-weight: 600;
    color: #333;
}
        
 .overlay-close-btn {
    position: absolute;
    right: 16px;
    top: 15px; /* Manually set distance from the top */
    background: none;
    border: none;
    cursor: pointer;
    color: #aaa;
    padding: 0;
    line-height: 1;
    transition: color 0.2s;
    width: 24px;
    height: 24px;
}

        .overlay-close-btn:hover {
            color: #333;
            
        }

        /* --- NEW CSS FOR OVERLAY GRID --- */
      .overlay-grid {
    padding: 20px;
    display: grid;
    /* This creates exactly 5 equal-width columns */
    grid-template-columns: repeat(5, 1fr);
    gap: 10px; /* Reduced gap to better fit 5 stickers */
    
}

        .overlay-sticker {
            width: 100%;
            height: auto;
            aspect-ratio: 1/1;
            object-fit: contain;
            cursor: grab;
            transition: transform 0.2s;
        }

        .overlay-sticker:hover {
            transform: scale(1.1);
        }

        .copy-btn-icon, .delete-btn-icon {
            width: 100%;
            height: 100%;
            fill: white;
            stroke: white;
        }

        .resize-handle-icon {
            width: 60%;
            height: 60%;
            fill: white;
            stroke: white;
        }

        .delete-btn, .copy-btn, .resize-handle {
            position: absolute;
            width: 20%;
            height: 20%;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 101;
            padding: 0;
            transition: transform 0.2s, background-color 0.2s;
        }

        .delete-btn {
            top: 5%;
            right: 5%;
            background-color: #c2bebeff;
        }

        .copy-btn {
            top: 5%;
            left: 5%;
            background-color: #c2bebeff;
        }

        .resize-handle {
            bottom: 5%;
            right: 5%;
            background-color: #c2bebeff;
            cursor: pointer;
        }

        .resize-handle:active {
            cursor: ne-resize;
        }

        .copy-btn:hover {
            background-color: #6aa84fff;
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .delete-btn:hover {
            background-color: #f26262ff;
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .resize-handle:hover {
            background-color: #FF5C00;
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }
        
        .pulse-effect {
    animation: pulse 0.5s ease-in-out;
}

@keyframes pulse {
    0% {
    transform: scale(1);
    }
    50% {
    transform: scale(1.1);
    }
    100% {
    transform: scale(1);
    }
}
    </style>

    <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body>
    <div class="controls">
    
    <button id="spin-sticker-btn" title="Würfeln">
    <i data-lucide="dice-6" class="icon"></i>
</button>

        <button id="add-sticker-btn" title="Überrasche mich">
            <i data-lucide="plus" class="icon"></i>
        </button>

        <button id="undo-btn" title="Zurück">
            <i data-lucide="undo-2" class="icon"></i>
        </button>

        <button id="redo-btn" title="Vor">
        <i data-lucide="redo-2" class="icon"></i>
    </button>
        
   
        <button id="new-btn" title="Neu">
            <i data-lucide="file-plus-2" class="icon"></i>
        </button>
    </div>

    <div class="color-palette-wrapper">
    <div class="color-palette-container">
        <div class="color-palette" id="color-palette"></div>
    </div>
        </div>

    <div id="canvas-container"></div>

    <div id="sticker-palette-container"></div>

    <div id="overlay-container" style="display: none;"></div>

    <script>
          const stickerGroups = [
          
{
name: "Día de los Muertos",
urls: [

"https://static.wixstatic.com/media/990059_03a221fd165d4a89b5124370626486ad~mv2.png",
"https://static.wixstatic.com/media/990059_682d393f5d77435da4ab7096708cb8d7~mv2.png",
"https://static.wixstatic.com/media/990059_4349efbaa2d24be8b017e957daad4a9e~mv2.png",
"https://static.wixstatic.com/media/990059_49720d322ef24087999ba4d482275662~mv2.png",
"https://static.wixstatic.com/media/990059_b18489e8975a47d5a487241d0d9f35f0~mv2.png",
"https://static.wixstatic.com/media/990059_a8d0533c108f494aa845b9ff80c4fc84~mv2.png",
"https://static.wixstatic.com/media/990059_dba27be6d625437e966be5841737db29~mv2.png",
"https://static.wixstatic.com/media/990059_e8c8d6ac987448cb8889c4f597c014fb~mv2.png",
"https://static.wixstatic.com/media/990059_23c7997d627c400da2a4f931d2df4a51~mv2.png",
"https://static.wixstatic.com/media/990059_e0c4743c307045e9aabf7b57f68b4b7e~mv2.png",
"https://static.wixstatic.com/media/990059_5adc058fc36e4080b7cee077a0174f59~mv2.png",
"https://static.wixstatic.com/media/990059_f2b8533239eb42cdaa89579bef97fd42~mv2.png",
"https://static.wixstatic.com/media/990059_0a066802fe8f4113acf9d74073af28f3~mv2.png",
"https://static.wixstatic.com/media/990059_46267e59e16f4d6b9b0985f4546c58f0~mv2.png",
"https://static.wixstatic.com/media/990059_a22468d7506a4094b48e9709f436d886~mv2.png",
"https://static.wixstatic.com/media/990059_4f26d9e09d3541108934a89f95419ef8~mv2.png",
"https://static.wixstatic.com/media/990059_ddd1138a462a4214b3f011f6f070e4ff~mv2.png",
"https://static.wixstatic.com/media/990059_b2e189bef2084da5b2cc54fae201da06~mv2.png",
"https://static.wixstatic.com/media/990059_f31737e926ba42d48db52abd305e88f8~mv2.png",
"https://static.wixstatic.com/media/990059_28a8ca536ea84c9c8179e5ef06f8b0ad~mv2.png",
"https://static.wixstatic.com/media/990059_7ee0ac7365db45ee9fba4bad3bf804dc~mv2.png",
"https://static.wixstatic.com/media/990059_7190e1e630b34197bee6f5925a073b07~mv2.png",
"https://static.wixstatic.com/media/990059_d5099b5806d1487eb7f6f37a0dab8ee1~mv2.png",
"https://static.wixstatic.com/media/990059_7779fdbeca784abf975cdd9c90297fa7~mv2.png",
"https://static.wixstatic.com/media/990059_45c15098a4cd468bb58cd67bb0ec8ddd~mv2.png",
"https://static.wixstatic.com/media/990059_079cbe0471204f59bc373fca7ed5bb8a~mv2.png",
"https://static.wixstatic.com/media/990059_034576676e974d128a6af3b901050979~mv2.png",
"https://static.wixstatic.com/media/990059_7c98bbc20aab4bccafb8729ce192c67f~mv2.png",
"https://static.wixstatic.com/media/990059_bc3de2f513594c86917b0e2326efcf8a~mv2.png",
"https://static.wixstatic.com/media/990059_79a921a872224dc7b6d04de5c55bda2b~mv2.png",
"https://static.wixstatic.com/media/990059_5f395576e10d4fbf8c7379f7ea89d6d4~mv2.png",
"https://static.wixstatic.com/media/990059_d0a92839ce0049c1aa89b97943d394d1~mv2.png",
"https://static.wixstatic.com/media/990059_08ef2737f12c4b31b89ea2a1651eb6e1~mv2.png",
"https://static.wixstatic.com/media/990059_281fd072e0e04f4e8cf1569188b8a30a~mv2.png",
"https://static.wixstatic.com/media/990059_395b8ec40a6945579ff1a493ab9483ac~mv2.png"

]
},

{
name: "Zulu",
urls: [

"https://static.wixstatic.com/media/990059_ebcddfd98c1e4dc0b62ae280d13400d4~mv2.png",
"https://static.wixstatic.com/media/990059_fb28597b3e934901b24ea56c70cd251e~mv2.png",
"https://static.wixstatic.com/media/990059_4dc9f12ccdc444f6b513c3ef52daee78~mv2.png",
"https://static.wixstatic.com/media/990059_e40835c13c4a44e0a14736238061a772~mv2.png",
"https://static.wixstatic.com/media/990059_0a9b16bed516447094cc67917789195d~mv2.png",
"https://static.wixstatic.com/media/990059_b52f919a40d24c8b9a34ab71888ca857~mv2.png",
"https://static.wixstatic.com/media/990059_15b6a3bc8e84440d9583d1b83e3d598c~mv2.png",
"https://static.wixstatic.com/media/990059_0bfcc3bb23bc4c8b9b37acdaf3e6b2d6~mv2.png",
"https://static.wixstatic.com/media/990059_8ebfac4726aa43f48c2374d7fb6bc70c~mv2.png",
"https://static.wixstatic.com/media/990059_5e9a398270f24cca981a1b7a98b25e65~mv2.png",
"https://static.wixstatic.com/media/990059_b6f2f99e235444e98295484404827f3b~mv2.png",
"https://static.wixstatic.com/media/990059_0376999057424754a2b98167ec6a6f99~mv2.png",
"https://static.wixstatic.com/media/990059_b5a6a1789b6f4edf80a187e580181b68~mv2.png",
"https://static.wixstatic.com/media/990059_8f8f53abd6bb49e8977b51ca7a72a6d8~mv2.png",
"https://static.wixstatic.com/media/990059_5263a42c53764f85810b51e49509a481~mv2.png",
"https://static.wixstatic.com/media/990059_9626fa28ca104b3981ac427f911bd124~mv2.png",
"https://static.wixstatic.com/media/990059_c6d1ba9e3e59474d9e4613104727c664~mv2.png",
"https://static.wixstatic.com/media/990059_02fad7d56aa34422a2f2f5009d79c6ee~mv2.png",
"https://static.wixstatic.com/media/990059_e5f3629b5b2a4fb58b3fcb6d66db0656~mv2.png",
"https://static.wixstatic.com/media/990059_ce84e83c7cf64054ab9a3d14a8727eee~mv2.png",
"https://static.wixstatic.com/media/990059_70703e8f4eb2400bb3a2794a9d2b30a1~mv2.png",
"https://static.wixstatic.com/media/990059_7bb16089e07b4a87824ee66326eec83d~mv2.png",
"https://static.wixstatic.com/media/990059_3741222f3ad044869262fc8a3de0f2a9~mv2.png",
"https://static.wixstatic.com/media/990059_b5ea812823a1417880ed7957c8d869ff~mv2.png",
"https://static.wixstatic.com/media/990059_c82cda1fbd024e73bf3ebc202ca98f1e~mv2.png",
"https://static.wixstatic.com/media/990059_dea51e1b23aa4d37961a76d4167be966~mv2.png",
"https://static.wixstatic.com/media/990059_82ddb672dfca4aaaa506708a8e81136f~mv2.png",
"https://static.wixstatic.com/media/990059_b9cd82b4f836457e84aaf7bdf6855909~mv2.png",
"https://static.wixstatic.com/media/990059_b1a74d918acf41c0ba210ea84572f089~mv2.png",
"https://static.wixstatic.com/media/990059_e7c337369b8f440ca612b1d4092b78e2~mv2.png",
"https://static.wixstatic.com/media/990059_bf7b64bb50804119ab5b14b9e1c7c6ce~mv2.png",
"https://static.wixstatic.com/media/990059_5d7ef870b2f4406c8601f64d5b4e2d0c~mv2.png",
"https://static.wixstatic.com/media/990059_f7d42b9e0fd7488ba09fd62a84a03cbc~mv2.png",
"https://static.wixstatic.com/media/990059_3580839d05684e54a4ee289c790e30ea~mv2.png",
"https://static.wixstatic.com/media/990059_a7766ba179fc42728328c6e273d3dcd0~mv2.png"

]
},

            
        ];


const spinBtn = document.getElementById("spin-sticker-btn");
        const canvas = document.getElementById('canvas-container');
        const addStickerBtn = document.getElementById('add-sticker-btn');
        const undoBtn = document.getElementById('undo-btn');
                    const redoBtn = document.getElementById('redo-btn');

        const newBtn = document.getElementById('new-btn');
        const paletteContainer = document.getElementById('sticker-palette-container');
        const overlayContainer = document.getElementById('overlay-container');
        const colorPalette = document.getElementById('color-palette');
        const history = [];
        const colorPaletteContainer = document.querySelector('.color-palette-container');


        let bucketMode = false;
        let activeSticker = null;
        let activePaletteSticker = null;
        let selectedColor = null;
        let isRestoring = false;
        let redoStack = [];

        let initialX, initialY, offsetX, offsetY;
        let initialTouchDistance = 0;
        let initialStickerWidth = 0;
        let initialStickerHeight = 0;

        let initialCenter = { x: 0, y: 0 };
        let firstStickerAdded = false;

      const colors = [
    // Skin tones
    '#8d5524', '#c68642', '#e0ac69', '#f1c27d', '#ffdbac',

    // Reds
    '#FF0000', '#FF6347', '#D2691E', '#CD5C5C', '#800020', // burgundy added

    // Oranges & Yellows
    '#FFA500', '#FF8C00', '#FFD700', '#FFFF00', '#FFC04C', '#a67c00', 
    '#FF7F50', // coral
    '#DAA520', // goldenrod
    '#C2B280', // sand beige

    // Greens
    '#008000', '#3CB371', '#9ACD32', '#ADFF2F',
    '#013220', // deep forest green
    '#808000', // olive green

    // Blues
    '#0000FF', '#4169E1', '#1E90FF', '#87CEFA',
    '#000080', // navy
    '#008080', // teal
    '#40E0D0', // turquoise

    // Purples
    '#800080', '#4B0082', '#BA55D3', '#DA70D6',

    // Pinks & Browns
    '#FFC0CB', '#FF69B4', '#FA8072', '#A52A2A', '#8B4513',

    // Grays & Neutrals
    '#C0C0C0', '#808080', 
    '#A9A9A9', // dark gray / stone gray

    // Brights
    '#ff71ce', '#01cdfe', '#05ffa1', '#b967ff', '#fffb96',

    // Pastels
    '#ffb3ba', '#ffdfba', '#ffffba', '#baffc9', '#bae1ff',
    '#ffdef2', '#f2e2ff', '#e2eeff', '#ddfffc', '#ffffe3'
];
        
  

        function setBucketMode(enabled) {
            bucketMode = enabled;
            if (bucketMode) {
                document.body.classList.add('bucket-active');
                canvas.style.cursor = 'crosshair';
                document.querySelectorAll('.color-swatch').forEach(swatch => {
                    swatch.draggable = false;
                });
            } else {
                document.body.classList.remove('bucket-active');
                canvas.style.cursor = 'default';
                document.querySelectorAll('.color-swatch').forEach(swatch => {
                    swatch.draggable = true;
                });
            }
        }

    function saveState() {
    if (isRestoring) return;
    const stickersOnCanvas = document.querySelectorAll('#canvas-container .sticker');
    const currentState = { stickers: [] };

    stickersOnCanvas.forEach(sticker => {
        const stickerImg = sticker.querySelector('img');
        
        if (stickerImg) {
            currentState.stickers.push({
                // ✅ Save the current `src`, which could be a URL or base64 data
                url: stickerImg.src, 
                x: sticker.offsetLeft,
                y: sticker.offsetTop,
                width: sticker.offsetWidth,
                height: sticker.offsetHeight,
                locked: sticker.classList.contains('locked'),
                group: sticker.dataset.group || null
            });
        }
    });

    const prevState = history[history.length - 1];
    if (JSON.stringify(prevState) !== JSON.stringify(currentState)) {
        history.push(currentState);
    }

    redoStack = [];
    updateUndoRedoButtons();
}

    function loadState(state) {
    isRestoring = true;
    canvas.innerHTML = '';
    
    state.stickers.forEach(data => {
        // Create the sticker first
        const newSticker = addSticker(
            data.url, 
            data.x, 
            data.y, 
            data.width, 
            data.height, 
            { suppressSave: true , group: data.group}
        );

        // ✅ ADD THIS CHECK: If the sticker was saved as locked, re-apply the class
        if (data.locked) {
            newSticker.classList.add('locked');
        }
    });
    
    isRestoring = false;
    updateUndoRedoButtons(); // Also, ensure this matches the function name from saveState
}

        function deselectAllStickers() {
            document.querySelectorAll('.sticker').forEach(s => {
                s.classList.remove('selected');
            });
        }

        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

function getRandomStickerUrlFromGroups() {
    if (!stickerGroups || stickerGroups.length === 0) {
        console.log("⚠️ No stickerGroups available");
        return null;
    }

    // Flatten into objects with url + group
    const allStickers = stickerGroups.flatMap(group =>
        group.urls.map(url => ({ url, group: group.name }))
    );

    if (allStickers.length === 0) {
        console.log("⚠️ No stickers in groups");
        return null;
    }

    const randomIndex = Math.floor(Math.random() * allStickers.length);
    return allStickers[randomIndex]; // { url, group }
}

function addRandomStickerOnLoad() {
    const randomStickerData = getRandomStickerUrlFromGroups();
    
    if (randomStickerData) {
        // Calculate the center position of the canvas
        const canvas = document.getElementById('canvas-container');
        const x = (canvas.offsetWidth / 2) - 50; // Center it horizontally
        const y = (canvas.offsetHeight / 2) - 50; // Center it vertically
        
        // Add the sticker to the canvas
        addSticker(
            randomStickerData.url, 
            x, 
            y, 
            100, // A default width for the sticker
            null, // Let height auto-adjust
            { group: randomStickerData.group, suppressSave: true }
        );
        
        // Save the initial state to the history
        saveState();
    }
}

// Call the function on page load
document.addEventListener('DOMContentLoaded', addRandomStickerOnLoad);

spinBtn.addEventListener("click", () => {
    let stickerImg = document.querySelector('#canvas-container .sticker img');
    if (!stickerImg) {
        console.log("ℹ️ No sticker found, adding first one");
        const firstObj = getRandomStickerUrlFromGroups(); 
        if (firstObj) {
            addOrReplaceSticker(firstObj.url, { group: firstObj.group });
            stickerImg = document.querySelector('#canvas-container .sticker img');
        } else {
            console.warn("⚠️ No valid sticker URL was returned. Cannot add a sticker.");
            return;
        }
    }
    if (!stickerImg) {
        console.warn("⚠️ Still no sticker, aborting spin");
        return;
    }

    let spinCount = 0;
    const maxSpins = 15 + Math.floor(Math.random() * 10);

    const spinInterval = setInterval(() => {
        const nextObj = getRandomStickerUrlFromGroups(); // { url, group }
        if (nextObj) {
            stickerImg.src = nextObj.url;  // ✅ correct reference
            const stickerDiv = stickerImg.closest('.sticker');
            if (stickerDiv) {
                stickerDiv.dataset.group = nextObj.group;
            }
        }
        
        spinCount++;
        if (spinCount >= maxSpins) {
            clearInterval(spinInterval);

            // Add the pulse effect
            const stickerDiv = stickerImg.closest('.sticker');
            if (stickerDiv) {
                stickerDiv.classList.add('pulse-effect');
                setTimeout(() => {
                    stickerDiv.classList.remove('pulse-effect');
                }, 3000);
            }

            saveState();
        }
    }, 100);
});


function addOrReplaceSticker(newUrl, groupName = null) {
    const unlockedSticker = document.querySelector('.sticker:not(.locked)');
    const stickerSize = 120;
    const canvasWidth = canvas.offsetWidth;
    const canvasHeight = canvas.offsetHeight;
    const centerX = (canvasWidth / 2) - (stickerSize / 2);
    const centerY = (canvasHeight / 2) - (stickerSize / 2);

    if (unlockedSticker) {
        const stickerImg = unlockedSticker.querySelector('img');
        stickerImg.src = newUrl;

        unlockedSticker.style.width = `${stickerSize}px`;
        unlockedSticker.style.height = `${stickerSize}px`;
        unlockedSticker.style.left = `${centerX}px`;
        unlockedSticker.style.top = `${centerY}px`;

        // ✅ Keep existing group or assign new one
        if (groupName) {
            unlockedSticker.dataset.group = groupName;
        } else if (!unlockedSticker.dataset.group) {
            unlockedSticker.dataset.group = stickerGroups[0]?.name || 'default';
        }

        stickerImg.onload = () => {
            unlockedSticker.style.opacity = '1';
        };

        console.log('[addOrReplaceSticker] Replaced sticker group:', unlockedSticker.dataset.group);
    } else {
        const newGroup = groupName || stickerGroups[0]?.name || 'default';
        addSticker(newUrl, centerX, centerY, stickerSize, stickerSize, { group: newGroup });
        console.log('[addOrReplaceSticker] Created new sticker with group:', newGroup);
    }

    saveState();
}


function addSticker(url, x, y, width = 120, height = 120, opts = {}) {
    const { suppressSave = false ,  group} = opts;
                    const sticker = document.createElement('div');
                        const groupName = group || 'default';
    sticker.dataset.group = groupName;
            sticker.classList.add('sticker');
            sticker.style.width = `${width}px`;
            sticker.style.height = `${height}px`;

            const stickerImg = document.createElement('img');
            stickerImg.crossOrigin = "Anonymous";
            stickerImg.src = url;
            stickerImg.draggable = false;
            sticker.appendChild(stickerImg);

            sticker.addEventListener('click', (e) => {
                if (bucketMode && selectedColor) {
                    e.stopPropagation();
                    const rect = sticker.getBoundingClientRect();
                    const clickX = Math.floor((e.clientX - rect.left) * (stickerImg.naturalWidth / rect.width));
                    const clickY = Math.floor((e.clientY - rect.top) * (stickerImg.naturalHeight / rect.height));
                    recolorSticker(stickerImg, selectedColor, clickX, clickY);
                    
                }
            });

            const copyBtn = document.createElement('div');
            copyBtn.classList.add('copy-btn');
            copyBtn.innerHTML = `
                <svg class="copy-btn-icon" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="8" x2="12" y2="16" />
                    <line x1="8" y1="12" x2="16" y2="12" />
                </svg>
            `;

            copyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const stickerWidth = sticker.offsetWidth;
                const stickerHeight = sticker.offsetHeight;
                let newX = parseInt(sticker.style.left) + 10;
                let newY = parseInt(sticker.style.top) + 10;
                function isOverlapping(x, y) {
                    const stickers = document.querySelectorAll('.sticker');
                    return Array.from(stickers).some(s => {
                        const sx = parseInt(s.style.left);
                        const sy = parseInt(s.style.top);
                        const sw = s.offsetWidth;
                        const sh = s.offsetHeight;
                        return !(x + stickerWidth < sx || x > sx + sw || y + stickerHeight < sy || y > sy + sh);
                    });
                }
                const step = 10;
                let attempts = 0;
                while (isOverlapping(newX, newY) && attempts < 100) {
                    newX += step;
                    newY += step;
                    if (newX + stickerWidth > canvas.offsetWidth) newX = step;
                    if (newY + stickerHeight > canvas.offsetHeight) newY = step;
                    attempts++;
                }
                saveState();
                addSticker(
    sticker.querySelector('img').src, 
    newX, 
    newY, 
    sticker.offsetWidth, 
    sticker.offsetHeight, 
    { group: sticker.dataset.group }
);
            });

            const deleteBtn = document.createElement('div');
            deleteBtn.classList.add('delete-btn');
            deleteBtn.innerHTML = `
                <svg class="delete-btn-icon" viewBox="0 0 24 24">
                    <line x1="5" y1="12" x2="19" y2="12" stroke="white" stroke-width="1" />
                </svg>
            `;
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                saveState();
                sticker.remove();
            });

            const resizeHandle = document.createElement('div');
            resizeHandle.classList.add('resize-handle');
            resizeHandle.innerHTML = `
                <svg class="resize-handle-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="15 3 21 3 21 9"></polyline>
                    <polyline points="9 21 3 21 3 15"></polyline>
                    <line x1="21" y1="3" x2="14" y2="10"></line>
                    <line x1="3" y1="21" x2="10" y2="14"></line>
                </svg>
            `;

            sticker.appendChild(deleteBtn);
            sticker.appendChild(copyBtn);
            sticker.appendChild(resizeHandle);


const groupBtn = document.createElement('div');
groupBtn.classList.add('sticker-btn', 'group-btn');
groupBtn.innerHTML = `
<svg class="group-btn-icon" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M4 6h16M4 12h16M4 18h16"/>
</svg>`;



// On click, open overlay with this sticker's group
groupBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    const stickerGroup = sticker.dataset.group;
    const group = stickerGroups.find(g => g.name === stickerGroup);
    if (group) {
        // MODIFIED: Call the new showOverlay function
        showOverlay(e, group.name, group.urls);
    }
});

sticker.appendChild(groupBtn);

    function startInteraction(e) {
    if (e.target.closest('.delete-btn, .copy-btn, .lock-btn, .group-btn')) return;
                if (bucketMode) return;
                
                // Save state at the beginning of an interaction
                saveState();

                deselectAllStickers();
                sticker.classList.add('selected');

                e.preventDefault();
                activeSticker = sticker;

                initialCenter.x = sticker.offsetLeft + sticker.offsetWidth / 2;
                initialCenter.y = sticker.offsetTop + sticker.offsetHeight / 2;

                if (e.touches && e.touches.length === 2) {
                    initialTouchDistance = getTouchDistance(e.touches);
                    initialStickerWidth = sticker.offsetWidth;
                    initialStickerHeight = sticker.offsetHeight;
                } else if (e.touches && e.touches.length === 1) {
                    const touch = e.touches[0];
                    initialX = touch.clientX;
                    initialY = touch.clientY;
                    offsetX = sticker.offsetLeft;
                    offsetY = sticker.offsetTop;
                } else {
                    initialX = e.clientX;
                    initialY = e.clientY;
                    offsetX = sticker.offsetLeft;
                    offsetY = sticker.offsetTop;
                }

                document.addEventListener('mousemove', handleMove);
                document.addEventListener('mouseup', handleEnd);
                document.addEventListener('touchmove', handleMove, { passive: false });
                document.addEventListener('touchend', handleEnd);
            }

            function handleMove(e) {
                if (!activeSticker || bucketMode) return;
                e.preventDefault();

                if (e.touches && e.touches.length === 2) {
                    const newTouchDistance = getTouchDistance(e.touches);
                    const scaleChange = newTouchDistance / initialTouchDistance;
                    const newWidth = Math.max(initialStickerWidth * scaleChange, 30);
                    const aspectRatio = initialStickerWidth / initialStickerHeight;
                    const newHeight = newWidth / aspectRatio;

                    activeSticker.style.width = `${newWidth}px`;
                    activeSticker.style.height = `${newHeight}px`;

                    activeSticker.style.left = `${initialCenter.x - newWidth / 2}px`;
                    activeSticker.style.top = `${initialCenter.y - newHeight / 2}px`;

                } else {
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    const newX = offsetX + (clientX - initialX);
                    const newY = offsetY + (clientY - initialY);
                    activeSticker.style.left = `${newX}px`;
                    activeSticker.style.top = `${newY}px`;
                }
            }

            function handleEnd() {
                document.removeEventListener('mousemove', handleMove);
                document.removeEventListener('mouseup', handleEnd);
                document.removeEventListener('touchmove', handleMove);
                document.removeEventListener('touchend', handleEnd);
                activeSticker = null;
                // Save state here, AFTER the drag/resize is complete
                saveState();
            }

            function addResizeHandleListeners(handle, sticker) {
    let startX, startY, startWidth, startHeight, startLeft, startTop;

    const startResize = (e) => {
        e.stopPropagation();
        e.preventDefault();

        saveState();

        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        startX = clientX;
        startY = clientY;
        startWidth = sticker.offsetWidth;
        startHeight = sticker.offsetHeight;
        startLeft = sticker.offsetLeft;
        startTop = sticker.offsetTop;

        document.addEventListener('mousemove', doResize);
        document.addEventListener('mouseup', endResize);
        document.addEventListener('touchmove', doResize, { passive: false });
        document.addEventListener('touchend', endResize);
    };

    const doResize = (e) => {
        e.stopPropagation();
        e.preventDefault();

        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        const deltaX = clientX - startX;
        const newWidth = Math.max(startWidth + deltaX, 30);
        const aspectRatio = startWidth / startHeight;
        const newHeight = newWidth / aspectRatio;

        sticker.style.width = `${newWidth}px`;
        sticker.style.height = `${newHeight}px`;

        // The key change is here:
        // Adjust the top-left position to simulate resizing from the center or another anchor point.
        sticker.style.left = `${startLeft + (startWidth - newWidth) / 2}px`;
        sticker.style.top = `${startTop + (startHeight - newHeight) / 2}px`;

    };

    const endResize = () => {
        document.removeEventListener('mousemove', doResize);
        document.removeEventListener('mouseup', endResize);
        document.removeEventListener('touchmove', doResize);
        document.removeEventListener('touchend', endResize);
        saveState();
    };

    handle.addEventListener('mousedown', startResize);
    handle.addEventListener('touchstart', startResize);
}

            addResizeHandleListeners(resizeHandle, sticker);

            function addWheelResize(stickerImg) {
                let lastWheelTime = 0;
                let timeoutId = null;
                stickerImg.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    
                    // Save the state before the first scroll delta in a sequence
                    if (Date.now() - lastWheelTime > 200 || history.length === 0) {
                        saveState();
                    }

                    const parent = stickerImg.parentElement;
                    const delta = Math.sign(e.deltaY);

                    const initialWidth = parent.offsetWidth;
                    const initialHeight = parent.offsetHeight;

                    const initialLeft = parent.offsetLeft;
                    const initialTop = parent.offsetTop;

                    const newSize = initialWidth + (delta * 10);
                    const minSize = 30;

                    if (newSize >= minSize) {
                        const newHeight = newSize / (initialWidth / initialHeight);

                        parent.style.width = `${newSize}px`;
                        parent.style.height = `${newHeight}px`;

                        parent.style.left = `${initialLeft + (initialWidth - newSize) / 2}px`;
                        parent.style.top = `${initialTop + (initialHeight - newHeight) / 2}px`;
                    }
                    lastWheelTime = Date.now();
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => {
                        saveState();
                    }, 200);
                });
            }

            addWheelResize(stickerImg);

            sticker.addEventListener('mousedown', startInteraction);
            sticker.addEventListener('touchstart', startInteraction);

            canvas.addEventListener('mousedown', (e) => {
                if (!e.target.closest('.sticker')) {
                    deselectAllStickers();
                }
            });
            canvas.addEventListener('touchstart', (e) => {
                if (!e.target.closest('.sticker')) {
                    deselectAllStickers();
                }
            });

            let finalX, finalY;
            const canvasRect = canvas.getBoundingClientRect();
            const existingStickers = document.querySelectorAll('.sticker');

            if (existingStickers.length === 0) {
                finalX = (canvas.offsetWidth / 2) - (width / 2);
                finalY = (canvas.offsetHeight / 2) - (width / 2);
            } else if (x !== undefined && y !== undefined) {
                finalX = x;
                finalY = y;
            } else {
                const newStickerWidth = width;
                const newStickerHeight = (stickerImg.naturalHeight / stickerImg.naturalWidth) * newStickerWidth;
                let foundPosition = false;

                const step = newStickerWidth / 2;
                for (let yy = 0; yy < canvas.offsetHeight - newStickerHeight && !foundPosition; yy += step) {
                    for (let xx = 0; xx < canvas.offsetWidth - newStickerWidth && !foundPosition; xx += step) {
                        let overlap = false;
                        document.querySelectorAll('.sticker').forEach(existing => {
                            const rect = existing.getBoundingClientRect();
                            const ex = rect.left - canvasRect.left;
                            const ey = rect.top - canvasRect.top;
                            const ew = rect.width;
                            const eh = rect.height;

                            if (
                                xx < ex + ew &&
                                xx + newStickerWidth > ex &&
                                yy < ey + eh &&
                                yy + newStickerHeight > ey
                            ) {
                                overlap = true;
                            }
                        });

                        if (!overlap) {
                            finalX = xx;
                            finalY = yy;
                            foundPosition = true;
                        }
                    }
                }

                if (!foundPosition) {
                    finalX = Math.floor(Math.random() * (canvas.offsetWidth - newStickerWidth));
                    finalY = Math.floor(Math.random() * (canvas.offsetHeight - newStickerHeight));
                }
            }

            sticker.style.left = `${finalX}px`;
            sticker.style.top = `${finalY}px`;

            function updateButtonSizes() {
                const btnSize = sticker.offsetWidth * 0.2;
                [deleteBtn, copyBtn, resizeHandle,, groupBtn].forEach(btn => {
                    btn.style.width = btnSize + 'px';
                    btn.style.height = btnSize + 'px';
                });
                deleteBtn.style.top = deleteBtn.style.right = `${btnSize * 0.25}px`;
                copyBtn.style.top = copyBtn.style.left = `${btnSize * 0.25}px`;
                resizeHandle.style.bottom = resizeHandle.style.left = `${btnSize * 0.25}px`;
                groupBtn.style.bottom = groupBtn.style.right = `${btnSize * 0.25}px`;
            }

            updateButtonSizes();
            const observer = new ResizeObserver(updateButtonSizes);
            observer.observe(sticker);
            canvas.appendChild(sticker);
            
            // Save state after a sticker is added to the DOM
            if (!suppressSave && !isRestoring) {
    saveState();
}
            
            return sticker;
        }

        function populatePalette() {
            stickerGroups.forEach(group => {
                const paletteSticker = document.createElement('img');
                paletteSticker.src = group.urls[0];
                paletteSticker.classList.add('palette-sticker');
                paletteSticker.dataset.group = group.name;

                paletteSticker.addEventListener('click', (e) => {
                    if (activePaletteSticker === paletteSticker) {
                        hideOverlay();
                    } else {
                        hideOverlay();
                        // MODIFIED: Pass group name and URLs to the new function
                        showOverlay(e, group.name, group.urls);
                        activePaletteSticker = paletteSticker;
                    }
                });

                paletteSticker.draggable = true;

                paletteSticker.addEventListener('dragstart', (e) => {
    e.dataTransfer.setData('application/json', JSON.stringify({
        url: e.target.src,
        width: 120,
        group: e.target.dataset.group // ✅ include group
    }));
  
                });
                paletteContainer.appendChild(paletteSticker);
            });
        }

        function hideOverlay() {
            overlayContainer.style.display = 'none';
            activePaletteSticker = null;
        }

        let activeGroupURLs = [];
        
        // --- REWRITTEN JAVASCRIPT showOverlay FUNCTION ---
        function showOverlay(event, groupName, urls) {
            // Prevent default behavior if triggered by an event
            if (event) event.stopPropagation();
        
            overlayContainer.innerHTML = ''; // Clear previous content
        
            // --- Header ---
            const header = document.createElement('div');
            header.className = 'overlay-header';
        
            const title = document.createElement('h2');
            title.className = 'overlay-title';
            title.textContent = groupName; // Use the group name for the title
        
           const closeBtn = document.createElement('button');
closeBtn.className = 'overlay-close-btn';
// Replace the text 'X' with an SVG icon
closeBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
closeBtn.onclick = hideOverlay;
        
            header.appendChild(title);
            header.appendChild(closeBtn);
            overlayContainer.appendChild(header);
        
            // --- Grid of stickers ---
            const grid = document.createElement('div');
            grid.className = 'overlay-grid';
        
            urls.forEach(url => {
                const sticker = document.createElement('img');
                sticker.src = url;
                sticker.classList.add('overlay-sticker');
                sticker.draggable = true;
        
                // Click to add sticker to canvas
                sticker.addEventListener('click', (e) => {
                    e.stopPropagation();
                    addSticker(url, undefined, undefined, 120, 120, { group: groupName });
                    hideOverlay();
                });
        
                // Drag to canvas
                sticker.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('application/json', JSON.stringify({ url, group: groupName }));
                   
                });
        
                grid.appendChild(sticker);
            });
        
            overlayContainer.appendChild(grid);
        
            // Display the overlay
            overlayContainer.style.display = 'flex';
        }


        document.addEventListener('click', (e) => {
            // Updated to hide overlay if click is outside the new elements
            if (!paletteContainer.contains(e.target) && !overlayContainer.contains(e.target) && !e.target.closest('.group-btn')) {
                hideOverlay();
            }
        });

        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

 canvas.addEventListener('drop', (e) => {
    e.preventDefault();
    const data = e.dataTransfer.getData('application/json');
    if (data) {
        const { url, width, group } = JSON.parse(data);
        const rect = canvas.getBoundingClientRect();

        // MODIFIED: Sticker's top-left corner will now be at the cursor
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        addSticker(url, x, y, width, width, { group });
        hideOverlay();
    }
});

        function hexToRgb(hex) {
            hex = hex.replace(/^#/, "");
            const bigint = parseInt(hex, 16);
            return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
        }

function recolorSticker(stickerImg, fillColor, clickX, clickY) {
    const canvasEl = document.createElement("canvas");
    const ctx = canvasEl.getContext("2d", { willReadFrequently: true });
    canvasEl.width = stickerImg.naturalWidth;
    canvasEl.height = stickerImg.naturalHeight;
    ctx.drawImage(stickerImg, 0, 0);

    const imgData = ctx.getImageData(0, 0, canvasEl.width, canvasEl.height);
    const data = imgData.data;
    const { width, height } = canvasEl;



    // --- Inlined helper functions for performance ---
    const blackThreshold = 30;
    const tolerance = 30;

    const startIndex = (clickY * width + clickX) * 4;
    const targetColor = [
        data[startIndex],
        data[startIndex + 1],
        data[startIndex + 2],
        data[startIndex + 3]
    ];
    
    // Early exit if the clicked pixel is a border
    if (targetColor[3] > 0 && targetColor[0] < blackThreshold && targetColor[1] < blackThreshold && targetColor[2] < blackThreshold) {
        return; 
    }

    const visited = new Uint8Array(width * height);
    let touchesEdge = false;

    const stack = [[clickX, clickY]];

    // --- OPTIMIZATION 1: Run synchronously in a single loop ---
    while (stack.length) {
        let [x, y] = stack.pop();

        let left = x;
        while (left >= 0 && !visited[y * width + left] && isFillable(left, y)) {
            left--;
        }
        left++;

        let right = x;
        while (right < width && !visited[y * width + right] && isFillable(right, y)) {
            right++;
        }
        right--;

        // Fill the span
        for (let i = left; i <= right; i++) {
            const idx = y * width + i;
            visited[idx] = 1;
            const dataIndex = idx * 4;

            if (isEraser) {
                data[dataIndex + 3] = 0;
            } else {
                data[dataIndex] = r;
                data[dataIndex + 1] = g;
                data[dataIndex + 2] = b;
                data[dataIndex + 3] = 255;
            }

            if (i === 0 || i === width - 1 || y === 0 || y === height - 1) {
                touchesEdge = true;
            }
        }

        // --- OPTIMIZATION 2: Efficiently find and add new scanlines ---
        scan(y - 1, left, right); // Scan row above
        scan(y + 1, left, right); // Scan row below
    }

    // Helper to check if a pixel should be filled
    function isFillable(px, py) {
        if (px < 0 || px >= width || py < 0 || py >= height) return false;
        
        const idx = (py * width + px) * 4;
        const R = data[idx];
        const G = data[idx + 1];
        const B = data[idx + 2];
        const A = data[idx + 3];

        // Check if it's a border pixel
        if (A > 0 && R < blackThreshold && G < blackThreshold && B < blackThreshold) {
            return false;
        }

        // Check if it matches the target color
        return (
            Math.abs(R - targetColor[0]) <= tolerance &&
            Math.abs(G - targetColor[1]) <= tolerance &&
            Math.abs(B - targetColor[2]) <= tolerance &&
            Math.abs(A - targetColor[3]) <= tolerance
        );
    }
    
    // Helper to find new spans to add to the stack
    function scan(y, lx, rx) {
        if (y < 0 || y >= height) return;
        for (let x = lx; x <= rx; x++) {
            if (!visited[y * width + x] && isFillable(x, y)) {
                // We found a new, uncolored span. Push it and skip the rest of this span.
                stack.push([x, y]);
                // Fast-forward past the rest of this colored span
                while (x <= rx && isFillable(x, y)) {
                    x++;
                }
            }
        }
    }

    if (!touchesEdge) {
        ctx.putImageData(imgData, 0, 0);
        stickerImg.src = canvasEl.toDataURL();
        saveState(); // Call your state saving function
    }
}


        function updateUndoButton() {
            undoBtn.disabled = history.length <= 1;
        }

    undoBtn.addEventListener('click', () => {
    if (history.length > 1) {
        const lastState = history.pop();
        redoStack.push(lastState); // 👈 save for redo
        loadState(history[history.length - 1]);
        updateUndoRedoButtons();
    }
});

redoBtn.addEventListener('click', () => {
    if (redoStack.length > 0) {
        const nextState = redoStack.pop();
        history.push(nextState);
        loadState(nextState);
        updateUndoRedoButtons();
    }
});

function updateUndoRedoButtons() {
    undoBtn.disabled = history.length <= 1;
    redoBtn.disabled = redoStack.length === 0;
}

       newBtn.addEventListener('click', () => {
    // Clear the canvas
    canvas.innerHTML = '';
    
    // Add the empty state to the history
    // This allows the user to undo the "new" action.
    saveState();
    
    // Reset any other relevant flags
    firstStickerAdded = false;
});
        
    

    addStickerBtn.addEventListener('click', () => {
        const randomSticker = getRandomStickerUrlFromGroups();
        if (randomSticker) {
            addSticker(
                randomSticker.url, 
                undefined, undefined, 120, 120, 
                { group: randomSticker.group }
            );
        }
    });

        populatePalette();
        populateColorPalette();
        saveState();

        window.addEventListener('load', () => {
            if (window.lucide) {
                lucide.createIcons();
            }
        });

        let isDragging = false;
        let startX;
        let scrollLeft;
        let isSwiping = false;
        let initialTap = { clientX: 0 };

        function addSwipeFunctionality() {
            const paletteContainer = document.querySelector('.color-palette-container');
            const palette = document.querySelector('.color-palette');

            const handleStart = (e) => {
                isDragging = true;
                startX = e.type.includes('mouse') ? e.pageX - paletteContainer.offsetLeft : e.touches[0].clientX;
                scrollLeft = paletteContainer.scrollLeft;
                initialTap.clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
            };

            const handleMove = (e) => {
                if (!isDragging) return;
                e.preventDefault();
                const x = e.type.includes('mouse') ? e.pageX - paletteContainer.offsetLeft : e.touches[0].clientX;
                const walk = (x - startX) * 1.5;
                paletteContainer.scrollLeft = scrollLeft - walk;
                if (Math.abs(e.clientX - initialTap.clientX) > 10) {
                    isSwiping = true;
                }
            };

            const handleEnd = () => {
                isDragging = false;
                setTimeout(() => {
                    isSwiping = false;
                }, 100);
            };

            [paletteContainer, palette].forEach(element => {
                element.addEventListener('mousedown', handleStart);
                element.addEventListener('mousemove', handleMove);
                element.addEventListener('mouseup', handleEnd);
                element.addEventListener('mouseleave', handleEnd);

                element.addEventListener('touchstart', handleStart);
                element.addEventListener('touchmove', handleMove, { passive: false });
                element.addEventListener('touchend', handleEnd);
            });
        }

   colorPaletteContainer.addEventListener('wheel', (event) => {
    // Prevent the default vertical scrolling behavior
    event.preventDefault();

    // Scroll the container horizontally
    // event.deltaY is the vertical scroll amount,
    // so we use it to scroll the horizontal axis
    colorPaletteContainer.scrollLeft += event.deltaY;
});

        function populateColorPalette() {
            colorPalette.innerHTML = '';
            colors.forEach(color => {
                const swatch = document.createElement('div');
                swatch.classList.add('color-swatch');
                swatch.style.backgroundColor = color;
                
                if (selectedColor === color) {
                    swatch.classList.add('active');
                }

                swatch.addEventListener('click', (e) => {
                    if (isSwiping) return;
                    
                    document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));

                    const wasActive = swatch.classList.contains('active');
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                    
                    if (!wasActive) {
                        swatch.classList.add('active');
                        selectedColor = color;
                        setBucketMode(true);
                    } else {
                        selectedColor = null;
                        setBucketMode(false);
                    }
                });

            });
        }

        addSwipeFunctionality();
    
    document.addEventListener("contextmenu", function(e){
    e.preventDefault();
}, false);
    </script>
</body>
</html>
