<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sticker Canvas</title>
    <style>
      
    img.protected {
  -webkit-touch-callout: none; /* iOS Safari */
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  pointer-events: none; /* <- Optional: makes the image "unclickable" */
}
      
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            box-sizing: border-box;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
      
        }

        #canvas-container {
             position: relative; 
            width: 90%;
            max-width: 600px;
            height: 80vh;  
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
            position: relative;
            margin-top: 10px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-radius: 16px;
            touch-action: none;
        }
        
        .sticker {
            position: absolute;
            height: auto;
            cursor: grab;
            user-select: none;
            transition: transform 0.1s ease-in-out;
            box-sizing: border-box;
            touch-action: none;
        }

        .sticker img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .sticker:active {
            cursor: grabbing;
            z-index: 100;
        }
        
        .sticker:focus {
            outline: none;
        }

        .sticker:hover > .delete-btn,
        .sticker:hover > .copy-btn,
        .sticker:hover > .lock-btn {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sticker.selected > .delete-btn,
        .sticker.selected > .copy-btn,
        .sticker.selected > .lock-btn {
            display: flex;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .bucket-active .sticker {
            border: none !important;
            transition: none !important;
        }

         .bucket-active .sticker .delete-btn,
        .bucket-active .sticker .copy-btn,
        .bucket-active .sticker .lock-btn {
            display: none !important;
        }


        .bucket-active .sticker:active,
        .bucket-active .sticker:hover {
            cursor: crosshair;
        }

        .ghost-sticker {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.7;
            width: 100px;
            height: auto;
            transform: translate(-50%, -50%);
        }

        button {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: none;
            cursor: pointer;
            color: #333;
            transition: transform 0.2s, color 0.2s;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

        button:focus, button:active {
            outline: 0 !important;
            box-shadow: none !important;
        }
        
        button:hover {
            color: #000;
            transform: scale(1.1);
        }
        
        button.active {
            border-radius: 50%;
            background-color: #e0e0e0;
            transform: scale(1.05);
        }

        .icon {
            width: 1.4em;
            height: 1.4em;
            stroke: currentColor;
        }

        .color-palette-container {
            width: 90%;
            max-width: 600px;
            overflow-x: scroll;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
            touch-action: pan-y;
        }

        .color-palette-container::-webkit-scrollbar {
            display: none;  
        }

        .color-palette {
            display: flex;
            flex-wrap: nowrap;
            gap: 8px;
            margin-top: 10px;
            padding: 3px;
            width: max-content;
        }

        .color-swatch {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.2s, border-color 0.2s;
            flex-shrink: 0;
            outline: 0 !important;
            box-shadow: none !important;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }

        .color-swatch.active {
            border-color: #333;
            transform: scale(1.1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        #sticker-palette-container {
            display: none;
        }

        /* Overlay box (popup wrapper) */
.overlay {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #ccc;
  border-radius: 8px;
  padding: 10px;
  display: none;          /* <- start hidden */
  z-index: 200;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
  width: 80%;
  height: 90%;
  overflow-y: auto;

  /* grid layout for children */
  display: none;          /* important: no grid by default */
  grid-template-columns: repeat(4, 1fr);
  gap: 10px;

}

.close-btn {
  position: absolute;
  top: 5px;
  right: 5px;
  background: rgba(0, 0, 0, 0.6);
  color: white;
  border: none;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  font-size: 18px;
  cursor: pointer;
  z-index: 300;
}

.close-btn:hover {
  transform: scale(1.1);
}

/* Show overlay */
.overlay.active {
  display: block;
}

/* Content inside overlay (grid of groups or stickers) */
.overlay-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 10px;
  overflow-y: auto;
  height: calc(100% - 40px); /* leave space for close button */
}

/* Group icons */
.overlay-icon {
  width: 100%;
  height: auto;
  aspect-ratio: 1/1;
  object-fit: contain;
  cursor: pointer;
  border-radius: 8px;
  transition: transform 0.2s;
}

.overlay-icon:hover {
  transform: scale(1.05);
}

/* Stickers */
.overlay-sticker {
  width: 100%;
  height: auto;
  aspect-ratio: 1/1;
  object-fit: contain;
  cursor: pointer;
  border: 1px solid transparent;
  transition: transform 0.2s;
}

.overlay-sticker:hover {
  transform: scale(1.1);
}
        
        .copy-btn-icon {
            width: 100%;
            height: 100%;
            fill: white;
            stroke: white;
        }

      .lock-btn-icon {
            width: 60%;
            height: 60%;
            fill: white;
            stroke: white;
        }

        .delete-btn:focus,
        .copy-btn:focus,
        .lock-btn:focus,
        .delete-btn:active,
        .copy-btn:active,
        .lock-btn:active {
            outline: none;
            box-shadow: none;
        }

        .delete-btn-icon {
            width: 100%;
            height: 100%;
            fill: white;
            stroke: white;
        }
        
        .delete-btn {
            position: absolute;
            top: 5%;
            right: 5%;
            width: 20%;
            height: 20%;
            border-radius: 50%;
            background-color: #c2bebeff;
            color: white;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 101;
            padding: 0;
            transition: transform 0.2s, background-color 0.2s;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

        .copy-btn {
            position: absolute;
            top: 5%;
            left: 5%;
            width: 20%;
            height: 20%;
            border-radius: 50%;
            background-color: #c2bebeff;
            color: white;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 101;
            padding: 0;
            transition: transform 0.2s, background-color 0.2s;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .lock-btn {
            position: absolute;
            bottom: 5%;
            left: 50%;
            transform: translateX(-50%);
            width: 20%;
            height: 20%;
            border-radius: 50%;
            background-color: #c2bebeff;
            color: white;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 101;
            padding: 0;
            transition: transform 0.2s, background-color 0.2s;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

        .lock-btn:hover {
            transform: scale(1.1) translateX(-50%);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .sticker.locked .lock-btn {
            background-color: #ff9933; /* Orange when locked */
            transform: scale(1.1) translateX(-50%);
        }

        .copy-btn:hover {
            background-color: #6aa84fff;
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .delete-btn:hover {
            background-color: #f26262ff;
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

    #folder {
    position: absolute;
    bottom: 20px;
    right: 20px;
    width: 60px;
    height: 60px;
    
    border: 2px dotted #ccc;
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    transition: background-color 0.3s, transform 0.3s, border-color 0.3s;
    z-index: 1000;
}

#folder:hover {
    background-color: #d0d0d0;
    transform: scale(1.05);
}

#folder.drag-over {
  background: rgba(0, 200, 0, 0.1);
  box-shadow: 0 0 12px rgba(0, 200, 0, 0.6);
  border-radius: 12px;
  transform: scale(1.05);
  transition: all 0.2s ease;
}

.folder-icon {
    width: 25px;
    height: 25px;
    stroke: #888;
}

#folder-count {
    font-size: 12px;
    color: #555;
    margin-top: 5px;
    font-weight: 500;
}

#folder-overlay {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 80%;
  height: 80%;
  background: white;
  border-radius: 12px;
  padding: 20px;
  overflow-y: auto;
  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  gap: 12px;
  z-index: 10000;
   border: 1px solid #ccc;
            border-radius: 8px;
}

#folder-overlay .overlay-close {
  position: absolute;
  top: 8px;   /* move it further up */
  right: 8px; /* move it further right */
  z-index: 9999;
  background: #444;
  color: white;
  border: none;
  border-radius: 50%;
  width: 28px;
  height: 28px;
  font-size: 18px;
  line-height: 28px;
  text-align: center;
  cursor: pointer;
}

/* Disable any pointer style on the wrapper */
#folder-overlay .overlay-sticker-wrapper {
  position: relative;
  display: inline-block;
}

#folder-overlay .overlay-sticker {
  transform: none !important;
  box-shadow: none !important;
  border: none !important;
  cursor: default !important;
}


#folder-overlay .overlay-sticker:hover {
  transform: none !important;
  box-shadow: none !important;
  border: none !important;
  cursor: default !important;
}

/* delete button inside wrapper */
#folder-overlay .overlay-sticker-wrapper .delete-sticker-btn {
  position: absolute;
  top: 4px;
  right: 4px;
  background: #c2bebeff;
  color: white;
  border: none;
  border-radius: 50%;
  width: 22px;
  height: 22px;
  font-size: 16px;
  line-height: 20px;
  text-align: center;
  cursor: pointer;
  display: block;
}

#folder-overlay .overlay-sticker-wrapper .delete-sticker-btn:hover {
  background-color: #f26262ff;
}

#folder.full {
  border-color: red;
}

#folder.full .folder-icon {
  filter: hue-rotate(-50deg) saturate(5); /* tint to red */
  /* Or use: color: red; if it's an SVG or font icon */
}

/* Folder icon inside */
#folder.full .folder-icon {
  filter: hue-rotate(-50deg) saturate(5); /* tint to red */
  /* Or use: color: red; if it's an SVG or font icon */
}

/* The count */
#folder.full .folder-count {
  color: red;
  font-weight: bold;
}


@keyframes shake {
  0% { transform: translateX(0); }
  20% { transform: translateX(-5px); }
  40% { transform: translateX(5px); }
  60% { transform: translateX(-5px); }
  80% { transform: translateX(5px); }
  100% { transform: translateX(0); }
}

.overlay-save {
 
  border: none;
  border-radius: 6px;
  font-weight: bold;
  cursor: pointer;
  background: black;
  color: white;
  transition: background 0.2s, color 0.2s, opacity 0.2s;
}

.overlay-save:disabled {
  background: #ccc;   /* grey background */
  color: #666;        /* faded text */
  cursor: not-allowed;
  opacity: 0.7;
}

.controls.disabled button {
  pointer-events: none;
  opacity: 0.4;
}

#email-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(1);
  background: #fff;
  padding: 24px 20px;
  border-radius: 16px;
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.25);
  z-index: 11000;
  width: 320px;
  text-align: center;
  font-family: "Inter", sans-serif;
  transition: transform 0.2s ease, opacity 0.2s ease;
}

#email-popup.hidden {
  display: none;
  opacity: 0;
  transform: translate(-50%, -50%) scale(0.9);
}

#email-popup h3 {
  margin: 0 0 16px;
  font-size: 1.2rem;
  color: #333;
}

#email-popup input {
  width: 100%;
  padding: 10px 12px;
  margin: 12px 0;
  border: 1px solid #ddd;
  border-radius: 8px;
  font-size: 0.95rem;
  outline: none;
  transition: border-color 0.2s, box-shadow 0.2s;
  box-sizing: border-box; /* ‚úÖ keeps it inside the popup */
}
#email-popup input:focus {
  border-color: #0078ff;
  box-shadow: 0 0 0 2px rgba(0, 120, 255, 0.2);
}

#email-popup .popup-actions {
  display: flex;
  justify-content: space-between;
  margin-top: 14px;
  gap: 10px;
}

#email-popup button {
  flex: 1;
  padding: 10px 0;
  border: none;
  border-radius: 8px;
  font-size: 0.95rem;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.2s, transform 0.1s;
}

#email-popup #cancel-btn {
  background: #f2f2f2;
  color: #333;
}

#email-popup #cancel-btn:hover {
  background: #e0e0e0;
}

#email-popup #send-btn {
  background: #0078ff;
  color: white;
}

#email-popup #send-btn:hover {
  background: #0063cc;
}

#email-popup button:active {
  transform: scale(0.96);
}

#success-popup {
  position: fixed; /* make it consistent with loading & email */
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.25);
  z-index: 11001;
  text-align: center;
}


#success-popup.hidden {
  display: none;
}

.success-box p {
  margin-bottom: 10px;
  font-size: 16px;
}

.popup {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.2);
  z-index: 2000;
 
}

/* Loading popup */
#loading-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.2);
  z-index: 11001;
  text-align: center;
}

#loading-popup .popup-content {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 16px;
  
}

.hidden {
  display: none !important;
}

.dots::after {
  content: '';
  animation: dots 1.5s steps(3, end) infinite;
}

@keyframes dots {
  0%   { content: ''; }
  33%  { content: '.'; }
  66%  { content: '..'; }
  100% { content: '...'; }
}

#success-popup .success-ok-btn {
  background-color: #28a745;   /* nice green */
  color: white;
  border: none;
  border-radius: 8px;
  padding: 12px 24px;
  font-size: 18px;
  font-weight: bold;
  cursor: pointer;
  margin-top: 15px;
  transition: background-color 0.2s ease, transform 0.1s ease;
}

#success-popup .success-ok-btn:hover {
  background-color: #218838;
}

#success-popup .success-ok-btn:active {
  transform: scale(0.96);
}

#error-message {
  color: red;
  font-size: 13px;
  margin-top: -5px;
  margin-bottom: 8px;
  text-align: left;
}

#email-input.error {
  border: 1px solid red;
  outline: none;
}


#folder.success.pulse {
  animation: folderPulseGreen 0.5s ease;
}

@keyframes folderPulseGreen {
  0%   { transform: scale(1); box-shadow: 0 0 0px rgba(0, 200, 0, 0.6); }
  50%  { transform: scale(1.1); box-shadow: 0 0 15px rgba(0, 200, 0, 0.8); }
  100% { transform: scale(1); box-shadow: 0 0 0px rgba(0, 200, 0, 0.6); }
}

/* ‚ùå Red pulse (full) */
#folder.full.shake {
  animation: folderPulseRed 0.5s ease, shake 0.6s ease;
}

@keyframes folderPulseRed {
  0%   { transform: scale(1); box-shadow: 0 0 0px rgba(200, 0, 0, 0.6); }
  50%  { transform: scale(1.1); box-shadow: 0 0 15px rgba(200, 0, 0, 0.8); }
  100% { transform: scale(1); box-shadow: 0 0 0px rgba(200, 0, 0, 0.6); }
}

/* Shake effect */
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}
    </style>

    <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body>
   
    

   

   <div id="canvas-container">
  <div id="sticker-layer"></div>

  <!-- Folder INSIDE canvas -->
  <div id="folder" title="Drop stickers here to save">
    <svg xmlns="http://www.w3.org/2000/svg" 
         width="40" height="40" viewBox="0 0 24 24" fill="none" 
         stroke="currentColor" stroke-width="2" stroke-linecap="round" 
         stroke-linejoin="round" class="folder-icon lucide-folder">
      <path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 
               0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 
               2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 
               0 0 0 2 2z"/>
    </svg>
    <span id="folder-count">0/35</span>
  </div>
</div>

     <div class="controls">
        <button id="add-sticker-btn" title="Add Random">
            <i data-lucide="shuffle" class="icon"></i>
        </button>
        
        <button id="sticker-picker-btn" title="Choose Sticker">
            <i data-lucide="sticker" class="icon"></i>
        </button>
        
        <button id="undo-btn" title="Undo">
            <i data-lucide="undo-2" class="icon"></i>
        </button>

        <button id="redo-btn" title="Redo">
        <i data-lucide="redo-2" class="icon"></i>
    </button>
   
       
    </div>
    <div id="group-overlay-container" class="overlay"></div>
    <div id="sticker-overlay-container" class="overlay"></div>
    <div id="folder-overlay"></div> 

    

<!-- Email Popup -->
<div id="email-popup" class="email-popup hidden">
  <h3>Enter your email</h3>
  <input type="email" id="email-input" placeholder="your@email.com" required />
  <div id="email-error" class="error-message"></div>
  
  <div class="popup-actions">
    <button id="cancel-btn">Cancel</button>
    <button id="send-btn">Send</button>
  </div>
</div>

<div id="success-popup" class="hidden">
  <div class="success-box">
    <p id="success-message">Stickers saved successfully!</p>
     <button id="success-ok-btn" class="success-ok-btn">OK</button>
  </div>
</div>

<div id="loading-popup" class="hidden">
  <div class="popup-content">
    <p>Sticker werden gespeichert<span class="dots"></span></p>
  </div>
</div>

    <script>
        const stickerGroups = [
            {
                
                name: "Vikings",
                urls: [
                    "https://static.wixstatic.com/media/990059_195242b424cb450ea78b93e9de392511~mv2.png",
                    "https://static.wixstatic.com/media/990059_e5529716f6f64f77a4d7c250ab6cfb5a~mv2.png",
                    "https://static.wixstatic.com/media/990059_4636b8e42e674dccbb6117391652f10b~mv2.png",
                    "https://static.wixstatic.com/media/990059_b4c7121418e14667bfdf79aecfea0524~mv2.png",
                    "https://static.wixstatic.com/media/990059_c5244cbdc1014a0292d36824ce277bba~mv2.png",
                    "https://static.wixstatic.com/media/990059_82d1bde23b3f45709690e3b032b39f7a~mv2.png",
                    "https://static.wixstatic.com/media/990059_63d7cd18bf4245d687839909ceb3671c~mv2.png",
                    "https://static.wixstatic.com/media/990059_04487087ffd9403184e0562a09da9952~mv2.png",
                    "https://static.wixstatic.com/media/990059_0abecd8111674041bda6a9bc58a0325d~mv2.png",
                    "https://static.wixstatic.com/media/990059_3d5f1cfd966b460a9fc708fbadc23342~mv2.png",
             

                ]
            },
            
            
            
        ];

const saveBtn = document.getElementById("save-btn");
const popup = document.getElementById("email-popup");
const cancelBtn = document.getElementById("cancel-btn");
const sendBtn = document.getElementById("send-btn");
const emailInput = document.getElementById("email-input");

const folder = document.getElementById('folder');
const folderCount = document.getElementById('folder-count');
let folderUrls = [];
const MAX_FOLDER_IMAGES = 3;
const folderOverlay = document.getElementById('folder-overlay');

const canvas = document.getElementById('canvas-container');
const addStickerBtn = document.getElementById('add-sticker-btn');
const undoBtn = document.getElementById('undo-btn');
const redoBtn = document.getElementById('redo-btn');

const colorPalette = document.getElementById('color-palette');
const history = [];

const stickerPickerBtn = document.getElementById('sticker-picker-btn');
const groupOverlayContainer = document.getElementById('group-overlay-container');
const stickerOverlayContainer = document.getElementById('sticker-overlay-container');

let bucketMode = false;
let activeSticker = null;
let activePaletteSticker = null;
let selectedColor = null;
let isRestoring = false;
let redoStack = [];

let initialX, initialY, offsetX, offsetY;
let initialTouchDistance = 0;
let initialStickerWidth = 0;
let initialStickerHeight = 0;

let initialCenter = { x: 0, y: 0 };
let firstStickerAdded = false;

// This function now correctly handles replacing the sticker and centering it
function addOrReplaceSticker(newUrl) {
    const existingSticker = document.querySelector('#canvas-container .sticker');

    if (existingSticker) {
        existingSticker.querySelector('img').src = newUrl;
    } else {
        const stickerSize = 120;
        const canvasWidth = canvas.offsetWidth;
        const canvasHeight = canvas.offsetHeight;
        const centerX = (canvasWidth / 2) - (stickerSize / 2);
        const centerY = (canvasHeight / 2) - (stickerSize / 2);
        addSticker(newUrl, centerX, centerY, stickerSize);
    }
    saveState();
}

// Your new function to handle saving the data
async function saveFolderDataToWix(urls) {
    try {
        console.log("Saving to Wix CMS:", urls);
    } catch (error) {
        console.error("Failed to save stickers to Wix CMS:", error);
    }
}

function isInsideFolder(x, y) {
    const rect = folder.getBoundingClientRect();
    return (
        x >= rect.left &&
        x <= rect.right &&
        y >= rect.top &&
        y <= rect.bottom
    );
}

window.addEventListener("message", (event) => {
    if (event.data.type === "saveSuccess") {
        document.getElementById("loading-popup").classList.add("hidden");
        const count = event.data.urlAmount || 0;
        document.getElementById("success-message").textContent =
            `Saved ${count} stickers successfully!`;
        document.getElementById("success-popup").classList.remove("hidden");
    }
    if (event.data.type === "saveError") {
        document.getElementById("loading-popup").classList.add("hidden");
        alert("‚ùå Something went wrong: " + event.data.error);
    }
});

// Cancel hides popup
cancelBtn.addEventListener("click", () => {
    popup.classList.add("hidden");
});

function showSuccessPopup() {
    document.getElementById("success-popup").classList.remove("hidden");
}

document.getElementById("success-ok-btn").addEventListener("click", () => {
    document.getElementById("success-popup").classList.add("hidden");
});

sendBtn.addEventListener("click", () => {
    const email = emailInput.value.trim();
    const errorDiv = document.getElementById("email-error");
    const popup = document.getElementById("email-popup");
    if (!email || !email.includes("@")) {
        emailInput.classList.add("error");
        errorDiv.textContent = "Please enter a valid email.";
        return;
    }
    emailInput.classList.remove("error");
    errorDiv.textContent = "";
    popup.classList.add("hidden");
    document.getElementById("loading-popup").classList.remove("hidden");
    document.querySelector(".controls").classList.remove("disabled");
    enablePaletteStickers();
    window.parent.postMessage({
        type: "saveStickers",
        urls: folderUrls,
        email: email
    }, "*");
});

// --- Desktop Drag & Drop ---
folder.addEventListener('dragover', (e) => {
    e.preventDefault();
    if (folderUrls.length < MAX_FOLDER_IMAGES) {
        folder.classList.add('drag-over');
    }
});

folder.addEventListener('dragleave', () => {
    folder.classList.remove('drag-over');
});

folder.addEventListener("drop", (e) => {
    e.preventDefault();
    folder.classList.remove("drag-over");
    if (folderUrls.length >= MAX_FOLDER_IMAGES) {
        updateFolderUI();
        console.warn("üö´ Folder limit reached");
        return;
    }
    const jsonData = e.dataTransfer.getData("application/json");
    if (jsonData) {
        try {
            const { url } = JSON.parse(jsonData);
            addToFolder(url);
        } catch (err) {
            console.error("Invalid JSON drop", err);
        }
        return;
    }
    const stickerDivId = e.dataTransfer.getData("text/plain");
    if (stickerDivId) {
        const stickerToMove = document.getElementById(stickerDivId);
        if (stickerToMove && stickerToMove.classList.contains("sticker")) {
            const stickerUrl = stickerToMove.querySelector("img").src;
            addToFolder(stickerUrl, stickerToMove);
        }
    }
});





function addToFolder(stickerUrl, stickerEl) {
    if (stickerEl) {
        stickerEl.remove();
    }

    folderUrls.push(stickerUrl);
    folderCount.textContent = `${folderUrls.length}/${MAX_FOLDER_IMAGES}`;
    saveFolderDataToWix(folderUrls);
    updateFolderUI();

    // ‚õîÔ∏è The fix: Clear the undo/redo history after adding to the folder.
    // This prevents the back button from bringing the sticker back.
    history = [];
    redoStack = [];
    updateUndoRedoButtons();
}

function renderFolderOverlay() {
    folderOverlay.innerHTML = "";
    document.querySelector(".controls").classList.add("disabled");
    const saveBtn = document.createElement("button");
    saveBtn.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" fill="currentColor" viewBox="0 0 24 24">
            <path d="M17 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V7zM12 19a2 2 0 1 1 0-4 
            2 2 0 0 1 0 4zm3-10H5V5h10z"/>
        </svg>
    `;
    saveBtn.className = "overlay-save";
    saveBtn.disabled = true;
    saveBtn.addEventListener("click", () => {
        if (folderUrls.length === 0) return;
        console.log("üíæ Save button clicked");
        popup.classList.remove("hidden");
    });
    folderOverlay.appendChild(saveBtn);

    function updateSaveButton() {
        saveBtn.disabled = folderUrls.length === 0;
    }
    updateSaveButton();
    const closeBtn = document.createElement("button");
    closeBtn.textContent = "√ó";
    closeBtn.className = "overlay-close";
    closeBtn.addEventListener("click", () => {
        folderOverlay.style.display = "none";
        document.querySelector(".controls").classList.remove("disabled");
        enablePaletteStickers();
    });
    folderOverlay.appendChild(closeBtn);
    if (folderUrls.length === 0) {
        const emptyMsg = document.createElement("p");
        emptyMsg.className = "empty-msg";
        folderOverlay.appendChild(emptyMsg);
    } else {
        folderUrls.forEach((url, index) => {
            const wrapper = document.createElement("div");
            wrapper.className = "overlay-sticker-wrapper";
            const img = document.createElement("img");
            img.src = url;
            img.className = "overlay-sticker";
            const delBtn = document.createElement("button");
            delBtn.textContent = "‚Äì";
            delBtn.className = "delete-sticker-btn";
            delBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                folderUrls.splice(index, 1);
                saveFolderDataToWix(folderUrls);
                updateFolderUI();
                renderFolderOverlay();
            });
            wrapper.appendChild(img);
            wrapper.appendChild(delBtn);
            folderOverlay.appendChild(wrapper);
        });
    }
    folderOverlay.style.display = "grid";
    disablePaletteStickers();
}

folderOverlay.addEventListener("dragover", (e) => {
    e.preventDefault();
});

folderOverlay.addEventListener("drop", (e) => {
    e.preventDefault();
    let jsonData = e.dataTransfer.getData("application/json");
    if (jsonData) {
        try {
            const { url } = JSON.parse(jsonData);
            if (url && !folderUrls.includes(url)) {
                folderUrls.push(url);
                saveFolderDataToWix(folderUrls);
                updateFolderUI();
                renderFolderOverlay();
            }
            return;
        } catch (err) {
            console.error("Invalid JSON drop into folder", err);
        }
    }
    const stickerId = e.dataTransfer.getData("text/plain");
    if (stickerId) {
        const draggedEl = document.getElementById(stickerId);
        if (draggedEl && draggedEl.src && !folderUrls.includes(draggedEl.src)) {
            folderUrls.push(draggedEl.src);
            saveFolderDataToWix(folderUrls);
            updateFolderUI();
            renderFolderOverlay();
        }
    }
});

// --- CLICK TO OPEN OVERLAY ---
folder.addEventListener("click", () => {
    renderFolderOverlay();
});

function disablePaletteStickers() {
    document.querySelector("#sticker-palette-container").classList.add("disabled");
}

function enablePaletteStickers() {
    document.querySelector("#sticker-palette-container").classList.remove("disabled");
}

function updateFolderUI() {
    folderCount.textContent = `${folderUrls.length}/${MAX_FOLDER_IMAGES}`;
    if (folderUrls.length >= MAX_FOLDER_IMAGES) {
        folder.classList.add("full");
    } else {
        folder.classList.remove("full");
    }
}

function setBucketMode(enabled) {
    bucketMode = enabled;
    if (bucketMode) {
        document.body.classList.add('bucket-active');
        canvas.style.cursor = 'crosshair';
        document.querySelectorAll('.color-swatch').forEach(swatch => {
            swatch.draggable = false;
        });
    } else {
        document.body.classList.remove('bucket-active');
        canvas.style.cursor = 'default';
        document.querySelectorAll('.color-swatch').forEach(swatch => {
            swatch.draggable = true;
        });
    }
}

function saveState() {
    if (isRestoring) return;

    const stickersOnCanvas = document.querySelectorAll('#canvas-container .sticker');
    const currentState = {
        stickers: []
    };

    stickersOnCanvas.forEach(sticker => {
        const stickerImg = sticker.querySelector('img');
        if (stickerImg) {
            currentState.stickers.push({
                url: stickerImg.src
                // no x, y, width, height, locked anymore
            });
        }
    });

    const prevState = history[history.length - 1];
    if (JSON.stringify(prevState) !== JSON.stringify(currentState)) {
        history.push(currentState);
    }

    redoStack = [];
    updateUndoButton();
}

function loadState(state) {
    isRestoring = true;

    // Clear only stickers from canvas
    document.querySelectorAll('#canvas-container .sticker').forEach(sticker => {
        canvas.removeChild(sticker);
    });

    // Recreate stickers centered (or however you prefer)
    state.stickers.forEach(data => {
        const stickerSize = 120;
        const canvasWidth = canvas.offsetWidth;
        const canvasHeight = canvas.offsetHeight;
        const centerX = (canvasWidth / 2) - (stickerSize / 2);
        const centerY = (canvasHeight / 2) - (stickerSize / 2);

        addSticker(data.url, centerX, centerY, stickerSize, stickerSize, {
            suppressSave: true
        });
    });

    isRestoring = false;
    updateUndoRedoButtons();
}


function deselectAllStickers() {
    document.querySelectorAll('.sticker').forEach(s => {
        s.classList.remove('selected');
    });
}

function getTouchDistance(touches) {
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    return Math.sqrt(dx * dx + dy * dy);
}

function addSticker(url, x, y, width = 200, height = 200, opts = {}) {
    const { suppressSave = false } = opts;
    const sticker = document.createElement('div');
    sticker.classList.add('sticker');
    sticker.style.width = width + 'px';
    sticker.style.height = 'auto';
    const stickerImg = document.createElement('img');
    stickerImg.crossOrigin = "Anonymous";
    stickerImg.src = url;
    stickerImg.draggable = false;
    stickerImg.classList.add("protected");
    sticker.appendChild(stickerImg);

    const canvasWidth = canvas.offsetWidth;
    const canvasHeight = canvas.offsetHeight;
    const centerX = (canvasWidth - width) / 2;
    const centerY = (canvasHeight - height) / 2;

    sticker.style.left = `${centerX}px`;
    sticker.style.top = `${centerY}px`;
    
    if (x !== undefined && y !== undefined) {
        sticker.style.left = `${x}px`;
        sticker.style.top = `${y}px`;
    }

    const copyBtn = document.createElement('div');
    copyBtn.classList.add('copy-btn');
    copyBtn.innerHTML = `<svg class="copy-btn-icon" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="12" y1="8" x2="12" y2="16" />
        <line x1="8" y1="12" x2="16" y2="12" />
    </svg>`;
    copyBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const stickerWidth = sticker.offsetWidth;
        const stickerHeight = sticker.offsetHeight;
        let newX = parseInt(sticker.style.left) + 10;
        let newY = parseInt(sticker.style.top) + 10;
        function isOverlapping(x, y) {
            const stickers = document.querySelectorAll('.sticker');
            return Array.from(stickers).some(s => {
                const sx = parseInt(s.style.left);
                const sy = parseInt(s.style.top);
                const sw = s.offsetWidth;
                const sh = s.offsetHeight;
                return !(x + stickerWidth < sx || x > sx + sw || y + stickerHeight < sy || y > sy + sh);
            });
        }
        const step = 10;
        let attempts = 0;
        while (isOverlapping(newX, newY) && attempts < 100) {
            newX += step;
            newY += step;
            if (newX + stickerWidth > canvas.offsetWidth) newX = step;
            if (newY + stickerHeight > canvas.offsetHeight) newY = step;
            attempts++;
        }
        saveState();
        addSticker(stickerImg.src, newX, newY, sticker.offsetWidth);
    });

    const deleteBtn = document.createElement('div');
    deleteBtn.classList.add('delete-btn');
    deleteBtn.innerHTML = `<svg class="delete-btn-icon" viewBox="0 0 24 24">
        <line x1="5" y1="12" x2="19" y2="12" stroke="white" stroke-width="1" />
    </svg>`;
    deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        saveState();
        sticker.remove();
    });

    const lockBtn = document.createElement('div');
    lockBtn.innerHTML = `<svg class="lock-btn-icon" data-lucide="lock" viewBox="0 0 24 24">
        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
    </svg>`;
    lockBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        sticker.classList.toggle('locked');
        saveState();
    });

    sticker.appendChild(deleteBtn);
    sticker.appendChild(copyBtn);
    sticker.appendChild(lockBtn);

    function startInteraction(e) {
        if (e.target.closest('.delete-btn') || e.target.closest('.copy-btn') || e.target.closest('.lock-btn')) {
            return;
        }
        if (bucketMode && (!e.touches || e.touches.length < 2)) {
            return;
        }
        activeSticker = sticker;
        deselectAllStickers();
        sticker.classList.add('selected');
        saveState();
        if (e.touches && e.touches.length === 2) {
            e.preventDefault();
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
            initialStickerWidth = sticker.offsetWidth;
            initialStickerHeight = sticker.offsetHeight;
            initialRect = sticker.getBoundingClientRect();
            document.addEventListener('touchmove', handleMove, { passive: false });
        } else if (e.touches && e.touches.length === 1) {
            const touch = e.touches[0];
            initialX = touch.clientX;
            initialY = touch.clientY;
            offsetX = sticker.offsetLeft;
            offsetY = sticker.offsetTop;
            document.addEventListener('touchmove', handleMove, { passive: false });
        } else {
            initialX = e.clientX;
            initialY = e.clientY;
            offsetX = sticker.offsetLeft;
            offsetY = sticker.offsetTop;
            document.addEventListener('mousemove', handleMove);
        }
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
    }

    function handleMove(e) {
    if (!activeSticker) return;

    if (e.touches && e.touches.length === 2) {
        e.preventDefault();
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const currentPinchDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
        );
        const scaleFactor = currentPinchDistance / initialPinchDistance;
        const newWidth = initialStickerWidth * scaleFactor;
        const newHeight = initialStickerHeight * scaleFactor;
        const minSize = 30;

        if (newWidth >= minSize) {
            const isShrinking = newWidth < initialStickerWidth;
            const canvasRect = canvas.getBoundingClientRect();
            let adjustedLeft = initialRect.left;
            let adjustedTop = initialRect.top;

            if (isShrinking) {
                const widthDiff = initialStickerWidth - newWidth;
                const heightDiff = initialStickerHeight - newHeight;
                adjustedLeft = initialRect.left + widthDiff / 2;
                adjustedTop = initialRect.top + heightDiff / 2;

                if (adjustedLeft < canvasRect.left) adjustedLeft = canvasRect.left;
                if (adjustedTop < canvasRect.top) adjustedTop = canvasRect.top;
                if (adjustedLeft + newWidth > canvasRect.right)
                    adjustedLeft = canvasRect.right - newWidth;
                if (adjustedTop + newHeight > canvasRect.bottom)
                    adjustedTop = canvasRect.bottom - newHeight;
            } else {
                const widthDiff = newWidth - initialStickerWidth;
                const heightDiff = newHeight - initialStickerHeight;
                adjustedLeft = initialRect.left - widthDiff / 2;
                adjustedTop = initialRect.top - heightDiff / 2;
            }

            activeSticker.style.width = `${newWidth}px`;
            activeSticker.style.height = `${newHeight}px`;
            activeSticker.style.left = `${adjustedLeft - canvasRect.left}px`;
            activeSticker.style.top = `${adjustedTop - canvasRect.top}px`;
        }
    } else if (!bucketMode && (!e.touches || e.touches.length === 1)) {
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const dx = clientX - initialX;
        const dy = clientY - initialY;
        activeSticker.style.left = `${offsetX + dx}px`;
        activeSticker.style.top = `${offsetY + dy}px`;
    }

    if (activeSticker) {
        const folderRect = folder.getBoundingClientRect();
        const stickerRect = activeSticker.getBoundingClientRect();
        const isOverFolder =
            stickerRect.right > folderRect.left &&
            stickerRect.left < folderRect.right &&
            stickerRect.bottom > folderRect.top &&
            stickerRect.top < folderRect.bottom;

        // ‚úÖ Only glow if folder not full
        if (isOverFolder && folderUrls.length < MAX_FOLDER_IMAGES) {
            folder.classList.add("drag-over");
        } else {
            folder.classList.remove("drag-over");
        }
    }
}

 function handleEnd() {
    // Remove event listeners
    document.removeEventListener("mousemove", handleMove);
    document.removeEventListener("mouseup", handleEnd);
    document.removeEventListener("touchmove", handleMove);
    document.removeEventListener("touchend", handleEnd);

    if (activeSticker) {
        const folderRect = folder.getBoundingClientRect();
        const stickerRect = activeSticker.getBoundingClientRect();
        const isOverFolder =
            stickerRect.right > folderRect.left &&
            stickerRect.left < folderRect.right &&
            stickerRect.bottom > folderRect.top &&
            stickerRect.top < folderRect.bottom;

        if (isOverFolder) {
            if (folderUrls.length >= MAX_FOLDER_IMAGES) {
                folder.classList.add("full", "shake");
                setTimeout(() => folder.classList.remove("full", "shake"), 600);
                activeSticker.style.transition = "transform 0.3s ease, opacity 0.3s ease";
                activeSticker.style.transform = "translate(0,0) scale(1)";
                activeSticker.style.opacity = "1";
            } else {
                folder.classList.add("success", "pulse");
                setTimeout(() => folder.classList.remove("success", "pulse"), 500);
                const stickerUrl = activeSticker.querySelector("img").src;
                const dx =
                    folderRect.left + folderRect.width / 2 -
                    (stickerRect.left + stickerRect.width / 2);
                const dy =
                    folderRect.top + folderRect.height / 2 -
                    (stickerRect.top + stickerRect.height / 2);
                activeSticker.style.transition =
                    "transform 0.4s ease, opacity 0.4s ease";
                activeSticker.style.transform = `translate(${dx}px, ${dy}px) scale(0.1)`;
                activeSticker.style.opacity = "0";

                // This is the fix: move the reset logic inside the timeout
                setTimeout(() => {
                    addToFolder(stickerUrl, activeSticker);
                    if (activeSticker && activeSticker.parentNode === canvas) {
                        canvas.removeChild(activeSticker);
                    }
                    // Reset activeSticker here after removal
                    activeSticker = null; 
                }, 400);
            }
        } else {
            
          
           
            activeSticker.style.opacity = "1";
        }
        activeSticker.classList.remove("selected");
    }

    // Move this logic outside the `if (activeSticker)` block
    initialRect = null;
    initialTouchDistance = 0;
    initialStickerWidth = 0;
    initialStickerHeight = 0;
    saveState();
}

    sticker.addEventListener('mousedown', startInteraction);
    sticker.addEventListener('touchstart', startInteraction);
    sticker.addEventListener('wheel', (e) => {
        e.preventDefault();
        saveState();
        const parent = sticker;
        const delta = Math.sign(e.deltaY);
        const initialRect = parent.getBoundingClientRect();
        const initialWidth = initialRect.width;
        const initialHeight = initialRect.height;
        const newSize = initialWidth + (delta * 10);
        const minSize = 30;
        if (newSize >= minSize) {
            const newHeight = newSize / (initialWidth / initialHeight);
            const canvasRect = canvas.getBoundingClientRect();
            let adjustedLeft = initialRect.left;
            let adjustedTop = initialRect.top;
            const isShrinking = newSize < initialWidth;
            if (isShrinking) {
                adjustedLeft = initialRect.left + (initialWidth / 2) - (newSize / 2);
                adjustedTop = initialRect.top + (initialHeight / 2) - (newHeight / 2);
                if (adjustedLeft < canvasRect.left) adjustedLeft = canvasRect.left;
                if (adjustedTop < canvasRect.top) adjustedTop = canvasRect.top;
                if (adjustedLeft + newSize > canvasRect.right) adjustedLeft = canvasRect.right - newSize;
                if (adjustedTop + newHeight > canvasRect.bottom) adjustedTop = canvasRect.bottom - newHeight;
            } else {
                adjustedLeft = initialRect.left - (newSize - initialWidth) / 2;
                adjustedTop = initialRect.top - (newHeight - initialHeight) / 2;
            }
            parent.style.width = `${newSize}px`;
            parent.style.height = `${newHeight}px`;
            parent.style.left = `${adjustedLeft - canvasRect.left}px`;
            parent.style.top = `${adjustedTop - canvasRect.top}px`;
            saveState();
        }
    });

    stickerImg.addEventListener('click', (e) => {
        if (bucketMode && selectedColor) {
            e.stopPropagation();
            const rect = sticker.getBoundingClientRect();
            const clickX = Math.floor((e.clientX - rect.left) * (stickerImg.naturalWidth / rect.width));
            const clickY = Math.floor((e.clientY - rect.top) * (stickerImg.naturalHeight / rect.height));
            recolorSticker(stickerImg, selectedColor, clickX, clickY);
        }
    });

    const updateButtonSizes = () => {
        const btnSize = sticker.offsetWidth * 0.2;
        [deleteBtn, copyBtn, lockBtn].forEach(btn => {
            btn.style.width = btnSize + 'px';
            btn.style.height = btnSize + 'px';
        });
        deleteBtn.style.top = deleteBtn.style.right = `${btnSize * 0.25}px`;
        copyBtn.style.top = copyBtn.style.left = `${btnSize * 0.25}px`;
    };
    updateButtonSizes();
    const observer = new ResizeObserver(updateButtonSizes);
    observer.observe(sticker);
    canvas.appendChild(sticker);
    if (window.lucide) {
        lucide.createIcons();
    }
    if (!suppressSave && !isRestoring) {
        saveState();
    }
    return sticker;
}

function updateUndoButton() {
    undoBtn.disabled = history.length <= 1;
}

undoBtn.addEventListener('click', () => {
    if (history.length > 1) {
        const lastState = history.pop();
        redoStack.push(lastState);
        loadState(history[history.length - 1]);
        updateUndoRedoButtons();
    }
});

redoBtn.addEventListener('click', () => {
    if (redoStack.length > 0) {
        const nextState = redoStack.pop();
        history.push(nextState);
        loadState(nextState);
        updateUndoRedoButtons();
    }
});

function updateUndoRedoButtons() {
    undoBtn.disabled = history.length <= 1;
    redoBtn.disabled = redoStack.length === 0;
}

// MODIFIED: This function now correctly handles replacing the sticker and centering it
  function addOrReplaceSticker(newUrl) {
    const unlockedSticker = document.querySelector('.sticker:not(.locked)');
    const stickerSize = 120;
    const canvasWidth = canvas.offsetWidth;
    const canvasHeight = canvas.offsetHeight;
    const centerX = (canvasWidth / 2) - (stickerSize / 2);
    const centerY = (canvasHeight / 2) - (stickerSize / 2);

    if (unlockedSticker) {
        // Hide the sticker temporarily
        unlockedSticker.style.opacity = '0';
        
        // Update the sticker's properties
        unlockedSticker.querySelector('img').src = newUrl;
        unlockedSticker.style.width = `${stickerSize}px`;
        unlockedSticker.style.height = 'auto';
        unlockedSticker.style.left = `${centerX}px`;
        unlockedSticker.style.top = `${centerY}px`;
        
        // Use an event listener to show the sticker only after the image has loaded
        unlockedSticker.querySelector('img').onload = () => {
            unlockedSticker.style.opacity = '1';
        };

    } else {
        // Create a brand new sticker if none are unlocked
        addSticker(newUrl, centerX, centerY, stickerSize);
    }
    saveState();
}

addStickerBtn.addEventListener('click', () => {
    const allUrls = stickerGroups.flatMap(group => group.urls);
    const randomUrl = allUrls[Math.floor(Math.random() * allUrls.length)];
    addOrReplaceSticker(randomUrl);
});


addStickerBtn.addEventListener('click', () => {
    const allUrls = stickerGroups.flatMap(group => group.urls);
    const randomUrl = allUrls[Math.floor(Math.random() * allUrls.length)];
    addOrReplaceSticker(randomUrl);
});

window.addEventListener('load', () => {
    if (window.lucide) {
        lucide.createIcons();
    }
    updateCanvasDrop();
});

let isDragging = false;
let startX;
let scrollLeft;
let isSwiping = false;
let initialTap = { clientX: 0 };

function addSwipeFunctionality() {
    const handleStart = (e) => {
        isDragging = true;
        startX = e.type.includes('mouse') ? e.pageX - paletteContainer.offsetLeft : e.touches[0].clientX;
        scrollLeft = paletteContainer.scrollLeft;
        initialTap.clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
    };
    const handleMove = (e) => {
        if (!isDragging) return;
        e.preventDefault();
        const x = e.type.includes('mouse') ? e.pageX - paletteContainer.offsetLeft : e.touches[0].clientX;
        const walk = (x - startX) * 1.5;
        paletteContainer.scrollLeft = scrollLeft - walk;
        if (Math.abs(e.clientX - initialTap.clientX) > 10) {
            isSwiping = true;
        }
    };
    const handleEnd = () => {
        isDragging = false;
        setTimeout(() => {
            isSwiping = false;
        }, 100);
    };
    [paletteContainer, palette].forEach(element => {
        element.addEventListener('mousedown', handleStart);
        element.addEventListener('mousemove', handleMove);
        element.addEventListener('mouseup', handleEnd);
        element.addEventListener('mouseleave', handleEnd);
        element.addEventListener('touchstart', handleStart);
        element.addEventListener('touchmove', handleMove, { passive: false });
        element.addEventListener('touchend', handleEnd);
    });
}

function hideOverlays() {
    groupOverlayContainer.style.display = 'none';
    stickerOverlayContainer.style.display = 'none';
}

function showGroupOverlay() {
    hideOverlays();
    groupOverlayContainer.innerHTML = '';
    const closeBtn = document.createElement('button');
    closeBtn.textContent = '‚úï';
    closeBtn.classList.add('close-btn');
    closeBtn.addEventListener('click', hideOverlays);
    groupOverlayContainer.appendChild(closeBtn);
    stickerGroups.forEach(group => {
        const groupIcon = document.createElement('img');
        groupIcon.src = group.urls[0];
        groupIcon.classList.add('overlay-icon');
        groupIcon.title = group.name;
        groupIcon.addEventListener('click', () => {
            showStickerOverlay(group.urls);
        });
        groupOverlayContainer.appendChild(groupIcon);
    });
    groupOverlayContainer.style.display = 'grid';
}

function updateCanvasDrop() {
    const canvas = document.getElementById('canvas-container');
    canvas.removeEventListener('dragover', (e) => {
        e.preventDefault();
    });
    canvas.removeEventListener('drop', handleCanvasDrop);
    canvas.addEventListener('drop', handleCanvasDrop);
}

function handleCanvasDrop(e) {
    e.preventDefault();
    const data = e.dataTransfer.getData('application/json');
    if (data) {
        const { url, width } = JSON.parse(data);
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left - (width / 2);
        const y = e.clientY - rect.top - (width / 2);
        saveState();
        addSticker(url, x, y, width);
    }
}

let activeTouchSticker = null;
let touchOffsetX = 0;
let touchOffsetY = 0;

function showStickerOverlay(urls) {
    hideOverlays();
    stickerOverlayContainer.innerHTML = '';
    const closeBtn = document.createElement('button');
    closeBtn.textContent = '‚úï';
    closeBtn.classList.add('close-btn');
    closeBtn.addEventListener('click', hideOverlays);
    stickerOverlayContainer.appendChild(closeBtn);
    urls.forEach(url => {
        const sticker = document.createElement('img');
        sticker.src = url;
        sticker.classList.add('overlay-sticker');
        sticker.addEventListener('click', () => {
            addOrReplaceSticker(url);
            hideOverlays();
        });
        stickerOverlayContainer.appendChild(sticker);
    });
    stickerOverlayContainer.style.display = 'grid';
}

stickerPickerBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    if (groupOverlayContainer.style.display === 'grid') {
        hideOverlays();
    } else {
        showGroupOverlay();
    }
});

document.addEventListener('click', (e) => {
    if (!groupOverlayContainer.contains(e.target) && !stickerOverlayContainer.contains(e.target) && !stickerPickerBtn.contains(e.target)) {
        hideOverlays();
    }
});

canvas.removeEventListener('dragover', (e) => {
    e.preventDefault();
});

canvas.removeEventListener('drop', (e) => {
    e.preventDefault();
    const data = e.dataTransfer.getData('application/json');
    if (data) {
        const { url, width } = JSON.parse(data);
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        saveState();
        addSticker(url, x, y, width);
    }
});

addSwipeFunctionality();
populateColorPalette();
saveState();

// Block long-press save menu on mobile
document.addEventListener("touchstart", function(e) {
    if (e.target.tagName === "IMG" && e.target.classList.contains("protected")) {
        e.preventDefault();
    }
}, { passive: false });

document.addEventListener("contextmenu", function(e) {
    if (e.target.tagName === "IMG" && e.target.classList.contains("protected")) {
        e.preventDefault();
    }
}, false);


      
    </script>
</body>
</html>
