<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sticker Canvas</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 1vh;
            box-sizing: border-box;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #canvas-container {
            width: 90%;
            height: 500px;
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
            position: relative;
            margin-top: 10px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-radius: 16px;
            touch-action: none;
        }

        .sticker {
            position: absolute;
            height: auto;
            cursor: grab;
            user-select: none;
            transition: transform 0.1s ease-in-out;
            box-sizing: border-box;
            touch-action: none;
        }

        .sticker img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .sticker:active {
            cursor: grabbing;
            z-index: 100;
        }

        .sticker:focus {
            outline: none;
        }

        .sticker:hover > .delete-btn,
        .sticker:hover > .copy-btn,
        .sticker:hover > .resize-handle,
            .sticker:hover > .rotate-btn {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sticker.selected > .delete-btn,
        .sticker.selected > .copy-btn,
        .sticker.selected > .resize-handle,
            .sticker.selected > .rotate-btn {

            display: flex;
        }

        .controls {
            margin-top: 10px;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .bucket-active .sticker {
            border: none !important;
            transition: none !important;
        }

        .bucket-active .sticker .delete-btn,
        .bucket-active .sticker .copy-btn,
        .bucket-active .sticker .resize-handle {
            display: none !important;
        }

        .bucket-active .sticker:active,
        .bucket-active .sticker:hover {
            cursor: crosshair;
        }

        button {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: none;
            cursor: pointer;
            color: #333;
            transition: transform 0.2s, color 0.2s;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

        button:focus, button:active {
            outline: 0 !important;
            box-shadow: none !important;
        }

        button:hover {
            color: #000;
            transform: scale(1.1);
        }

        button.active {
            border-radius: 50%;
            background-color: #e0e0e0;
            transform: scale(1.05);
        }

        .icon {
            width: 1.4em;
            height: 1.4em;
            stroke: currentColor;
        }

        

    #sticker-palette-container {
    width: 100%;
    margin-top: 20px;
    padding: 5px;
    background-color: #f8f8f8;
    border: 1px solid #ddd;
    border-radius: 8px;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);

    display: flex;
    flex-wrap: nowrap;        /* single row */
    overflow-x: auto;         /* horizontal scroll */
    overflow-y: hidden;

    align-items: center;      /* vertical centering */
    justify-content: center;  /* horizontal centering */
    gap: 10px;                /* space between items */
    scrollbar-width: thin;
}

#sticker-palette-container::-webkit-scrollbar {
    height: 8px;
}

#sticker-palette-container::-webkit-scrollbar-thumb {
    background: #bbb; 
    border-radius: 4px;
}

        .palette-sticker {
            width: 60px;
            height: 60px;
            object-fit: contain;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s, transform 0.2s;
        }

        .palette-sticker:hover {
            transform: scale(1.1);
        }
        #overlay-container {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 20px;
            display: none;
            z-index: 200;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            width: 350px;
        }

        .overlay-sticker {
            width: 100%;
            height: auto;
            aspect-ratio: 1/1;
            object-fit: contain;
            cursor: grab;
            border: 1px solid transparent;
        }

        .overlay-sticker:hover {
            transform: scale(1.1);
        }

        .copy-btn-icon, .delete-btn-icon {
            width: 100%;
            height: 100%;
            fill: white;
            stroke: white;
        }

        .resize-handle-icon {
            width: 60%;
            height: 60%;
            fill: white;
            stroke: white;
        }

        .delete-btn, .copy-btn, .resize-handle {
            position: absolute;
            width: 20%;
            height: 20%;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 101;
            padding: 0;
            transition: transform 0.2s, background-color 0.2s;
        }

        .delete-btn {
            top: 5%;
            right: 5%;
            background-color: #c2bebeff;
        }

        .copy-btn {
            top: 5%;
            left: 5%;
            background-color: #c2bebeff;
        }

        .resize-handle {
            bottom: 5%;
            right: 5%;
            background-color: #c2bebeff;
            cursor: pointer;
        }

        .resize-handle:active {
            cursor: ne-resize;
        }

        .copy-btn:hover {
            background-color: #6aa84fff;
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .delete-btn:hover {
            background-color: #f26262ff;
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .resize-handle:hover {
            background-color: #4a86e8;
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }


.rotate-btn {
    position: absolute;
    width: 20%;
    height: 20%;
    border-radius: 50%;
    background-color: #c2bebeff;
    color: white;
    display: none;
    align-items: center;
    justify-content: center;
    cursor: grab;
    z-index: 101;
    padding: 0;
    transition: transform 0.2s, background-color 0.2s;

    bottom: 5%;
    left: 5%;
}

.rotate-btn:active {
    cursor: grabbing;
}

.rotate-btn:hover {
    background-color: #4a86e8;
    transform: scale(1.1);
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
}

.rotate-btn-icon {
    width: 60%;
    height: 60%;
    fill: white;
    stroke: white;
}

}

    </style>

    <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body>
    <div class="controls">
        <button id="add-sticker-btn" title="Add Random">
            <i data-lucide="shuffle" class="icon"></i>
        </button>

        <button id="undo-btn" title="Undo">
            <i data-lucide="undo-2" class="icon"></i>
        </button>

        <button id="redo-btn" title="Redo">
        <i data-lucide="redo-2" class="icon"></i>
    </button>
        
    
        <button id="new-btn" title="New Canvas">
            <i data-lucide="file-plus-2" class="icon"></i>
        </button>
    </div>


    <div id="canvas-container"></div>

    <div id="sticker-palette-container"></div>

    <div id="overlay-container"></div>

    <script>
        const stickerGroups = [
            {
                
                name: "Vikings",
                urls: [
                    "https://static.wixstatic.com/media/990059_a40c70232ee84ecfa996d9a6bbe71fb9~mv2.png"

                ]
            },
            {
                name: "2",
                urls: [
                    "https://static.wixstatic.com/media/990059_b8e966fff23243baaeffda0903b26ae5~mv2.png"
                    
            ]
           }, 
        ];
        
        


        const canvas = document.getElementById('canvas-container');
        const addStickerBtn = document.getElementById('add-sticker-btn');
        const undoBtn = document.getElementById('undo-btn');
                const redoBtn = document.getElementById('redo-btn');

        const newBtn = document.getElementById('new-btn');
        const paletteContainer = document.getElementById('sticker-palette-container');
        const overlayContainer = document.getElementById('overlay-container');
        const history = [];

        let bucketMode = false;
        let activeSticker = null;
        let activePaletteSticker = null;
        let selectedColor = null;
        let isRestoring = false;
        let redoStack = [];

        let initialX, initialY, offsetX, offsetY;
        let initialTouchDistance = 0;
        let initialStickerWidth = 0;
        let initialStickerHeight = 0;

        let initialCenter = { x: 0, y: 0 };
        let firstStickerAdded = false;

      
function setTransform(sticker) {
  const x = parseFloat(sticker.dataset.x) || 0;
  const y = parseFloat(sticker.dataset.y) || 0;
  const scale = parseFloat(sticker.dataset.scale) || 1;
  const rotation = parseFloat(sticker.dataset.rotation) || 0;

  sticker.style.transform =
    `translate(${x}px, ${y}px) scale(${scale}) rotate(${rotation}deg)`;
}


      function saveState() {
        if (isRestoring) return; 
            const stickersOnCanvas = document.querySelectorAll('#canvas-container .sticker');
            const currentState = {
                stickers: []
            };
            stickersOnCanvas.forEach(sticker => {
                const stickerImg = sticker.querySelector('img');
                if (stickerImg) {
                    currentState.stickers.push({
                        url: stickerImg.src,
                        x: sticker.offsetLeft,
                        y: sticker.offsetTop,
                        width: sticker.offsetWidth,
                        height: sticker.offsetHeight
                    });
                }
            });
            history.push(currentState);
             redoStack = []; 
            updateUndoButton();
        }

        function loadState(state) {
    isRestoring = true;
    canvas.innerHTML = '';
    state.stickers.forEach(data => {
        // pass suppressSave: true so addSticker doesn't push history while restoring
        addSticker(data.url, data.x, data.y, data.width, data.height, { suppressSave: true });
    });
    isRestoring = false;
    updateUndoButton();
}

        function deselectAllStickers() {
            document.querySelectorAll('.sticker').forEach(s => {
                s.classList.remove('selected');
            });
        }

        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

function addSticker(url, x, y, width = 200, height = 200, opts = {}) {
    const { suppressSave = false } = opts;
                const sticker = document.createElement('div');
            sticker.classList.add('sticker');
           sticker.style.width = `${width}px`;
            sticker.style.height = `${height}px`;

            const stickerImg = document.createElement('img');
            stickerImg.crossOrigin = "Anonymous";
            stickerImg.src = url;
            stickerImg.draggable = false;
            sticker.appendChild(stickerImg);

      

            const copyBtn = document.createElement('div');
            copyBtn.classList.add('copy-btn');
            copyBtn.innerHTML = `
                <svg class="copy-btn-icon" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="8" x2="12" y2="16" />
                    <line x1="8" y1="12" x2="16" y2="12" />
                </svg>
            `;

            copyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const stickerWidth = sticker.offsetWidth;
                const stickerHeight = sticker.offsetHeight;
                let newX = parseInt(sticker.style.left) + 10;
                let newY = parseInt(sticker.style.top) + 10;
                function isOverlapping(x, y) {
                    const stickers = document.querySelectorAll('.sticker');
                    return Array.from(stickers).some(s => {
                        const sx = parseInt(s.style.left);
                        const sy = parseInt(s.style.top);
                        const sw = s.offsetWidth;
                        const sh = s.offsetHeight;
                        return !(x + stickerWidth < sx || x > sx + sw || y + stickerHeight < sy || y > sy + sh);
                    });
                }
                const step = 10;
                let attempts = 0;
                while (isOverlapping(newX, newY) && attempts < 100) {
                    newX += step;
                    newY += step;
                    if (newX + stickerWidth > canvas.offsetWidth) newX = step;
                    if (newY + stickerHeight > canvas.offsetHeight) newY = step;
                    attempts++;
                }
                saveState();
                addSticker(stickerImg.src, newX, newY, sticker.offsetWidth);
            });

            const deleteBtn = document.createElement('div');
            deleteBtn.classList.add('delete-btn');
            deleteBtn.innerHTML = `
                <svg class="delete-btn-icon" viewBox="0 0 24 24">
                    <line x1="5" y1="12" x2="19" y2="12" stroke="white" stroke-width="1" />
                </svg>
            `;
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                saveState();
                sticker.remove();
            });
            
            
            
            
// Create rotate button
const rotateBtn = document.createElement('div');
rotateBtn.classList.add('rotate-btn');
rotateBtn.innerHTML = `
    <svg class="rotate-btn-icon" viewBox="0 0 24 24">
        <path d="M12 6v-4l-5 5 5 5v-4a5 5 0 1 1-5 5"
              stroke="white" stroke-width="2" fill="none"
              stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
`;
sticker.appendChild(rotateBtn);

// Rotation logic
let rotating = false;
let startAngle = 0;

rotateBtn.addEventListener("pointerdown", (e) => {
    e.stopPropagation();
    e.preventDefault();
    rotating = true;

    const rect = sticker.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    function getAngle(clientX, clientY) {
        return Math.atan2(clientY - centerY, clientX - centerX) * 180 / Math.PI;
    }

    // start from stored rotation
    let baseRotation = parseFloat(sticker.dataset.rotation) || 0;

    // last pointer angle reference (updates on every move)
    let lastPointerAngle = getAngle(e.clientX, e.clientY);

    function onMove(ev) {
        if (!rotating) return;

        const pointerAngle = getAngle(ev.clientX, ev.clientY);

        // difference since last move
        let delta = pointerAngle - lastPointerAngle;

        // normalize to -180..180
        if (delta > 180) delta -= 360;
        if (delta < -180) delta += 360;

        // accumulate
        baseRotation += delta;

        // update for next move
        lastPointerAngle = pointerAngle;

        // store & render
        sticker.dataset.rotation = baseRotation;
        setTransform(sticker);
    }

    function onUp() {
        rotating = false;
        window.removeEventListener("pointermove", onMove);
        window.removeEventListener("pointerup", onUp);
    }

    window.addEventListener("pointermove", onMove);
    window.addEventListener("pointerup", onUp);
});

            const resizeHandle = document.createElement('div');
            resizeHandle.classList.add('resize-handle');
            resizeHandle.innerHTML = `
                <svg class="resize-handle-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="15 3 21 3 21 9"></polyline>
                    <polyline points="9 21 3 21 3 15"></polyline>
                    <line x1="21" y1="3" x2="14" y2="10"></line>
                    <line x1="3" y1="21" x2="10" y2="14"></line>
                </svg>
            `;

            sticker.appendChild(deleteBtn);
            sticker.appendChild(copyBtn);
            sticker.appendChild(resizeHandle);

            function startInteraction(e) {
               if (
  e.target.closest(".delete-btn") ||
  e.target.closest(".copy-btn") ||
  e.target.closest(".resize-handle") ||
  e.target.closest(".rotate-btn")
) return;
                if (bucketMode) return;
                
                // Save state at the beginning of an interaction
                saveState();

                deselectAllStickers();
                sticker.classList.add('selected');

                e.preventDefault();
                activeSticker = sticker;

                initialCenter.x = sticker.offsetLeft + sticker.offsetWidth / 2;
                initialCenter.y = sticker.offsetTop + sticker.offsetHeight / 2;

                if (e.touches && e.touches.length === 2) {
                    initialTouchDistance = getTouchDistance(e.touches);
                    initialStickerWidth = sticker.offsetWidth;
                    initialStickerHeight = sticker.offsetHeight;
                } else if (e.touches && e.touches.length === 1) {
                    const touch = e.touches[0];
                    initialX = touch.clientX;
                    initialY = touch.clientY;
                    offsetX = sticker.offsetLeft;
                    offsetY = sticker.offsetTop;
                } else {
                    initialX = e.clientX;
                    initialY = e.clientY;
                    offsetX = sticker.offsetLeft;
                    offsetY = sticker.offsetTop;
                }

                document.addEventListener('mousemove', handleMove);
                document.addEventListener('mouseup', handleEnd);
                document.addEventListener('touchmove', handleMove, { passive: false });
                document.addEventListener('touchend', handleEnd);
            }

            function handleMove(e) {
                if (!activeSticker || bucketMode) return;
                e.preventDefault();

                if (e.touches && e.touches.length === 2) {
                    const newTouchDistance = getTouchDistance(e.touches);
                    const scaleChange = newTouchDistance / initialTouchDistance;
                    const newWidth = Math.max(initialStickerWidth * scaleChange, 30);
                    const aspectRatio = initialStickerWidth / initialStickerHeight;
                    const newHeight = newWidth / aspectRatio;

                    activeSticker.style.width = `${newWidth}px`;
                    activeSticker.style.height = `${newHeight}px`;

                    activeSticker.style.left = `${initialCenter.x - newWidth / 2}px`;
                    activeSticker.style.top = `${initialCenter.y - newHeight / 2}px`;

                } else {
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    const newX = offsetX + (clientX - initialX);
                    const newY = offsetY + (clientY - initialY);
                    activeSticker.style.left = `${newX}px`;
                    activeSticker.style.top = `${newY}px`;
                }
            }

            function handleEnd() {
                document.removeEventListener('mousemove', handleMove);
                document.removeEventListener('mouseup', handleEnd);
                document.removeEventListener('touchmove', handleMove);
                document.removeEventListener('touchend', handleEnd);
                activeSticker = null;
                // Save state here, AFTER the drag/resize is complete
                saveState();
            }

            function addResizeHandleListeners(handle, sticker) {
    let startX, startY, startWidth, startHeight, startLeft, startTop;

    const startResize = (e) => {
    e.stopPropagation();
    e.preventDefault();

    saveState();

    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

    startX = clientX;
    startY = clientY;

    startScale = parseFloat(sticker.dataset.scale) || 1;

    document.addEventListener('mousemove', doResize);
    document.addEventListener('mouseup', endResize);
    document.addEventListener('touchmove', doResize, { passive: false });
    document.addEventListener('touchend', endResize);
};

const doResize = (e) => {
    e.preventDefault();

    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

    const dx = clientX - startX;
    const dy = clientY - startY;

    // signed distance, so dragging left/up shrinks
    const distance = (dx + dy) / 200;

    const newScale = Math.max(0.2, startScale + distance);
    sticker.dataset.scale = newScale;

    setTransform(sticker);
};

const endResize = () => {
    document.removeEventListener('mousemove', doResize);
    document.removeEventListener('mouseup', endResize);
    document.removeEventListener('touchmove', doResize);
    document.removeEventListener('touchend', endResize);
};

    handle.addEventListener('mousedown', startResize);
    handle.addEventListener('touchstart', startResize);
}

            addResizeHandleListeners(resizeHandle, sticker);

            function addWheelResize(stickerImg) {
                let lastWheelTime = 0;
                let timeoutId = null;
                stickerImg.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    
                    // Save the state before the first scroll delta in a sequence
                    if (Date.now() - lastWheelTime > 200 || history.length === 0) {
                        saveState();
                    }

                    const parent = stickerImg.parentElement;
                    const delta = Math.sign(e.deltaY);

                    const initialWidth = parent.offsetWidth;
                    const initialHeight = parent.offsetHeight;

                    const initialLeft = parent.offsetLeft;
                    const initialTop = parent.offsetTop;

                    const newSize = initialWidth + (delta * 10);
                    const minSize = 30;

                    if (newSize >= minSize) {
                        const newHeight = newSize / (initialWidth / initialHeight);

                        parent.style.width = `${newSize}px`;
                        parent.style.height = `${newHeight}px`;

                        parent.style.left = `${initialLeft + (initialWidth - newSize) / 2}px`;
                        parent.style.top = `${initialTop + (initialHeight - newHeight) / 2}px`;
                    }
                    lastWheelTime = Date.now();
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => {
                        saveState();
                    }, 200);
                });
            }

            addWheelResize(stickerImg);

            sticker.addEventListener('mousedown', startInteraction);
            sticker.addEventListener('touchstart', startInteraction);

            canvas.addEventListener('mousedown', (e) => {
                if (!e.target.closest('.sticker')) {
                    deselectAllStickers();
                }
            });
            canvas.addEventListener('touchstart', (e) => {
                if (!e.target.closest('.sticker')) {
                    deselectAllStickers();
                }
            });

            let finalX, finalY;
            const canvasRect = canvas.getBoundingClientRect();
            const existingStickers = document.querySelectorAll('.sticker');

            if (existingStickers.length === 0) {
                finalX = (canvas.offsetWidth / 2) - (width / 2);
                finalY = (canvas.offsetHeight / 2) - (width / 2);
            } else if (x !== undefined && y !== undefined) {
                finalX = x;
                finalY = y;
            } else {
                const newStickerWidth = width;
                const newStickerHeight = (stickerImg.naturalHeight / stickerImg.naturalWidth) * newStickerWidth;
                let foundPosition = false;

                const step = newStickerWidth / 2;
                for (let yy = 0; yy < canvas.offsetHeight - newStickerHeight && !foundPosition; yy += step) {
                    for (let xx = 0; xx < canvas.offsetWidth - newStickerWidth && !foundPosition; xx += step) {
                        let overlap = false;
                        document.querySelectorAll('.sticker').forEach(existing => {
                            const rect = existing.getBoundingClientRect();
                            const ex = rect.left - canvasRect.left;
                            const ey = rect.top - canvasRect.top;
                            const ew = rect.width;
                            const eh = rect.height;

                            if (
                                xx < ex + ew &&
                                xx + newStickerWidth > ex &&
                                yy < ey + eh &&
                                yy + newStickerHeight > ey
                            ) {
                                overlap = true;
                            }
                        });

                        if (!overlap) {
                            finalX = xx;
                            finalY = yy;
                            foundPosition = true;
                        }
                    }
                }

                if (!foundPosition) {
                    finalX = Math.floor(Math.random() * (canvas.offsetWidth - newStickerWidth));
                    finalY = Math.floor(Math.random() * (canvas.offsetHeight - newStickerHeight));
                }
            }

            sticker.style.left = `${finalX}px`;
            sticker.style.top = `${finalY}px`;

            function updateButtonSizes() {
                const btnSize = sticker.offsetWidth * 0.2;
                [deleteBtn, copyBtn, resizeHandle].forEach(btn => {
                    btn.style.width = btnSize + 'px';
                    btn.style.height = btnSize + 'px';
                });
                deleteBtn.style.top = deleteBtn.style.right = `${btnSize * 0.25}px`;
                copyBtn.style.top = copyBtn.style.left = `${btnSize * 0.25}px`;
                resizeHandle.style.bottom = resizeHandle.style.right = `${btnSize * 0.25}px`;
            }

            updateButtonSizes();
            const observer = new ResizeObserver(updateButtonSizes);
            observer.observe(sticker);
            canvas.appendChild(sticker);
            
            // Save state after a sticker is added to the DOM
           if (!suppressSave && !isRestoring) {
    saveState();
}
            
            return sticker;

            sticker.dataset.x = x || 0;
sticker.dataset.y = y || 0;
sticker.dataset.scale = 1;
sticker.dataset.rotation = 0;
setTransform(sticker);
        }

        function populatePalette() {
            stickerGroups.forEach(group => {
                const paletteSticker = document.createElement('img');
                paletteSticker.src = group.urls[0];
                paletteSticker.classList.add('palette-sticker');
                paletteSticker.dataset.group = group.name;

                paletteSticker.addEventListener('click', (e) => {
                    if (activePaletteSticker === paletteSticker) {
                        hideOverlay();
                    } else {
                        hideOverlay();
                        showOverlay(e, group.urls);
                        activePaletteSticker = paletteSticker;
                    }
                });

                paletteSticker.draggable = true;
                paletteSticker.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('application/json', JSON.stringify({
                        url: e.target.src,
                        width: 200
                    }));
                    hideOverlay();
                });
                paletteContainer.appendChild(paletteSticker);
            });
        }

        function hideOverlay() {
            overlayContainer.style.display = 'none';
            activePaletteSticker = null;
        }

        let activeGroupURLs = [];

        function showOverlay(e, urls) {
            activeGroupURLs = urls;
            overlayContainer.innerHTML = '';
            urls.forEach(url => {
                const overlaySticker = document.createElement('img');
                overlaySticker.src = url;
                overlaySticker.classList.add('overlay-sticker');
                overlaySticker.draggable = true;
                overlaySticker.addEventListener('dragstart', (e) => {
                    e.stopPropagation();
                    e.dataTransfer.setData('application/json', JSON.stringify({
                        url: e.target.src,
                        width: 200
                    }));
                });
                overlaySticker.addEventListener('click', (e) => {
                    e.stopPropagation();
                    addSticker(url);
                    // saveState() is now in addSticker()
                });
                overlayContainer.appendChild(overlaySticker);
            });

            const rect = e.target.getBoundingClientRect();
            const paletteRect = paletteContainer.getBoundingClientRect();
            const { right, bottom } = rect;

            if (right + 260 < window.innerWidth) {
                overlayContainer.style.left = `${rect.right - paletteRect.left + 10}px`;
            } else {
                overlayContainer.style.left = `${rect.left - paletteRect.left - 260}px`;
            }

            if (bottom + overlayContainer.offsetHeight < window.innerHeight) {
                overlayContainer.style.top = `${rect.top - paletteRect.top}px`;
            } else {
                overlayContainer.style.top = `${rect.top - paletteRect.top - overlayContainer.offsetHeight}px`;
            }
            overlayContainer.style.display = 'grid';
        }

        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            const data = e.dataTransfer.getData('application/json');
            if (data) {
                const { url, width } = JSON.parse(data);
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                // saveState() is now in addSticker()
                addSticker(url, x, y, width);
            }
        });

        function hexToRgb(hex) {
            hex = hex.replace(/^#/, "");
            const bigint = parseInt(hex, 16);
            return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
        }


        function updateUndoButton() {
            undoBtn.disabled = history.length <= 1;
        }

   undoBtn.addEventListener('click', () => {
    if (history.length > 1) {
        const lastState = history.pop();
        redoStack.push(lastState); // ðŸ‘ˆ save for redo
        loadState(history[history.length - 1]);
        updateUndoRedoButtons();
    }
});

redoBtn.addEventListener('click', () => {
    if (redoStack.length > 0) {
        const nextState = redoStack.pop();
        history.push(nextState);
        loadState(nextState);
        updateUndoRedoButtons();
    }
});

function updateUndoRedoButtons() {
    undoBtn.disabled = history.length <= 1;
    redoBtn.disabled = redoStack.length === 0;
}

        newBtn.addEventListener('click', () => {
            canvas.innerHTML = '';
            history.splice(0);
            saveState();
            firstStickerAdded = false;
        });
        
  

        addStickerBtn.addEventListener('click', () => {
           

            const allUrls = stickerGroups.flatMap(group => group.urls);
            const randomUrl = allUrls[Math.floor(Math.random() * allUrls.length)];

            addSticker(randomUrl);
        });

        populatePalette();
       
        saveState();

        window.addEventListener('load', () => {
            if (window.lucide) {
                lucide.createIcons();
            }
        });

        let isDragging = false;
        let startX;
        let scrollLeft;
        let isSwiping = false;
        let initialTap = { clientX: 0 };

        function addSwipeFunctionality() {
          

            const handleStart = (e) => {
                isDragging = true;
                startX = e.type.includes('mouse') ? e.pageX - paletteContainer.offsetLeft : e.touches[0].clientX;
                scrollLeft = paletteContainer.scrollLeft;
                initialTap.clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
            };

           function handleMove(e) {
    // 1) If dragging a sticker on the canvas
    if (isDragging && activeSticker) {
        e.preventDefault();
        const clientX = e.type.includes('mouse') ? e.pageX : e.touches[0].clientX;
        const clientY = e.type.includes('mouse') ? e.pageY : e.touches[0].clientY;

        const dx = clientX - initialX;
        const dy = clientY - initialY;

        activeSticker.dataset.x = parseFloat(startStickerX) + dx;
        activeSticker.dataset.y = parseFloat(startStickerY) + dy;

        setTransform(activeSticker);
        return; // stop here, donâ€™t scroll palette
    }

    // 2) If dragging/swiping the palette
    if (!isDragging) return;
    e.preventDefault();

    const x = e.type.includes('mouse') ? e.pageX - paletteContainer.offsetLeft : e.touches[0].clientX;
    const walk = (x - startX) * 1.5;
    paletteContainer.scrollLeft = scrollLeft - walk;

    if (Math.abs(e.clientX - initialTap.clientX) > 10) {
        isSwiping = true;
    }
}

            const handleEnd = () => {
                isDragging = false;
                setTimeout(() => {
                    isSwiping = false;
                }, 100);
            };

            [paletteContainer, palette].forEach(element => {
                element.addEventListener('mousedown', handleStart);
                element.addEventListener('mousemove', handleMove);
                element.addEventListener('mouseup', handleEnd);
                element.addEventListener('mouseleave', handleEnd);

                element.addEventListener('touchstart', handleStart);
                element.addEventListener('touchmove', handleMove, { passive: false });
                element.addEventListener('touchend', handleEnd);
            });
        }

      
        addSwipeFunctionality();



    </script>
</body>
</html>
