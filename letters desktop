<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sticker Canvas</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 1vh;
            box-sizing: border-box;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #canvas-container {
            width: 90%;
            height: 500px;
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
            position: relative;
            margin-top: 10px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-radius: 16px;
            touch-action: none;
        }

        .sticker {
            position: absolute;
            height: auto;
            cursor: grab;
            user-select: none;
            transition: transform 0.1s ease-in-out;
            box-sizing: border-box;
            touch-action: none;
        }

        .sticker img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .sticker:active {
            cursor: grabbing;
            z-index: 100;
        }

        .sticker:focus {
            outline: none;
        }

        .sticker:hover > .delete-btn,
        .sticker:hover > .copy-btn,
        .sticker:hover > .resize-handle,
        .sticker:hover > .rotate-handle {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sticker.selected > .delete-btn,
        .sticker.selected > .copy-btn,
        .sticker.selected > .resize-handle,
        .sticker.selected > .rotate-handle {
            display: flex;
        }

        .controls {
            margin-top: 10px;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        button {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: none;
            cursor: pointer;
            color: #333;
            transition: transform 0.2s, color 0.2s;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

        button:focus, button:active {
            outline: 0 !important;
            box-shadow: none !important;
        }

        .group-btn {
  position: absolute;
  bottom: 5px;
  right: 5px;
  background: rgba(0,0,0,0.6);
  border-radius: 50%;
  padding: 4px;
  cursor: pointer;
}
.group-btn-icon {
  width: 16px;
  height: 16px;
}

        button:hover {
            color: #000;
            transform: scale(1.1);
        }

        button.active {
            border-radius: 50%;
            transform: scale(1.05);
        }

        .icon {
            width: 1.4em;
            height: 1.4em;
            stroke: currentColor;
        }

        #sticker-palette-container {
            width: 100%;
            margin-top: 20px;
            padding: 5px;
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-wrap: nowrap;
            overflow-x: auto;
            overflow-y: visible;
            align-items: center;
            justify-content: center;
            gap: 10px;
            scrollbar-width: thin;
        }

        #sticker-palette-container::-webkit-scrollbar {
            height: 8px;
        }

        #sticker-palette-container::-webkit-scrollbar-thumb {
            background: #bbb;
            border-radius: 4px;
        }

        .palette-sticker {
            width: 60px;
            height: 60px;
            object-fit: contain;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s, transform 0.2s;
            position: relative;
        }

.palette-sticker-wrapper {
  position: relative;
  display: inline-block;
  margin: 4px;
  overflow: visible; /* important, allows ::after to render outside */
}

.palette-sticker-wrapper::after {
  content: attr(data-label);
  position: absolute;
  bottom: calc(100% + -15px); /* just a small gap above */
  left: 50%;
  transform: translateX(-50%);
  padding: 4px 8px;
  background: rgba(0,0,0,0.75);
  color: #fff;
  font-size: 12px;
  white-space: nowrap;
  border-radius: 4px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s ease;
  z-index: 9999;
}

.palette-sticker-wrapper:hover::after {
  opacity: 1;
}

        .palette-sticker:hover {
            transform: scale(1.1);
        }

        #overlay-container {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 20px;
            display: none;
            z-index: 200;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            width: 350px;
        }

        .overlay-sticker {
            width: 100%;
            height: auto;
            aspect-ratio: 1/1;
            object-fit: contain;
            cursor: grab;
            border: 1px solid transparent;
        }

        .overlay-sticker:hover {
            transform: scale(1.1);
        }

        .copy-btn-icon, .delete-btn-icon {
            width: 100%;
            height: 100%;
            fill: white;
            stroke: white;
        }
        
        .resize-handle-icon ,  .rotate-handle-icon{
         width: 60%;
            height: 60%;
            }
        

        .delete-btn, .copy-btn, .resize-handle, .rotate-handle {
            position: absolute;
            width: 20%;
            height: 20%;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 101;
            padding: 0;
            transition: transform 0.2s, background-color 0.2s;
        }

        .delete-btn {
            top: 5%;
            right: 5%;
            background-color: #c2bebeff;
        }

        .copy-btn {
            top: 5%;
            left: 5%;
            background-color: #c2bebeff;
        }

        .resize-handle {
            bottom: 5%;
            right: 5%;
            background-color: #c2bebeff;
            cursor: pointer;
        }

        .rotate-handle {
            bottom: 5%;
            left: 5%;
            background-color: #c2bebeff;
            cursor: pointer;
        }

        .resize-handle:active, .rotate-handle:active {
            cursor: grabbing;
        }

        .copy-btn:hover {
            background-color: #6aa84fff;
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .delete-btn:hover {
            background-color: #f26262ff;
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .resize-handle:hover {
            background-color: #4a86e8;
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }
        
        .rotate-handle:hover {
            background-color: #FF5C00;
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .letter-dropdown-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .pulse-effect {
  animation: pulse 0.5s ease-in-out;
}

@keyframes pulse {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.1);
  }
  100% {
    transform: scale(1);
  }
}
    </style>

    <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body>

    <div class="controls">
        <div class="letter-dropdown-container">
        
            <select id="letter-select">
                <option value="A">A</option>
                <option value="B">B</option>
                <option value="C">C</option>
                <option value="D">D</option>
                <option value="E">E</option>
                <option value="F">F</option>
                <option value="G">G</option>
                <option value="H">H</option>
                <option value="I">I</option>
                <option value="J">J</option>
                <option value="K">K</option>
                <option value="L">L</option>
                <option value="M">M</option>
                <option value="N">N</option>
                <option value="O">O</option>
                <option value="P">P</option>
                <option value="Q">Q</option>
                <option value="R">R</option>
                <option value="S">S</option>
                <option value="T">T</option>
                <option value="U">U</option>
                <option value="V">V</option>
                <option value="W">W</option>
                <option value="X">X</option>
                <option value="Y">Y</option>
                <option value="Z">Z</option>
            </select>
        </div>

        
          
	<button id="spin-sticker-btn" title="Spin Random">
  <i data-lucide="dice-6" class="icon"></i>
</button>
        
        <button id="add-sticker-btn" title="Aufkleber hinzuf√ºgen">
            <i data-lucide="plus" class="icon"></i>
        </button>

        <button id="undo-btn" title="Zur√ºck">
            <i data-lucide="undo-2" class="icon"></i>
        </button>

        <button id="redo-btn" title="Vor">
            <i data-lucide="redo-2" class="icon"></i>
        </button>
        
        <button id="new-btn" title="Neu">
            <i data-lucide="file-plus-2" class="icon"></i>
        </button>
    </div>

    <div id="canvas-container"></div>

    <div id="sticker-palette-container"></div>

    <div id="overlay-container"></div>
    
    <script>
        const stickerGroups = [
            {
                name: "Asia",
                urls: {
                    "A": ["https://static.wixstatic.com/media/990059_efb2e73754a7449f96ad432ecb8de360~mv2.png"],
                    "B": ["https://static.wixstatic.com/media/990059_05e04c6e35424c098fcf4e971fa3a1be~mv2.png"]
                }
            },
            {
                name: "Bug",
                urls: {
                    "A": ["https://static.wixstatic.com/media/990059_896e4ce4fb094112aa5e524b4230f562~mv2.png"],
                    "B": ["https://static.wixstatic.com/media/990059_e49cdd1403a949019aeafce0185ac178~mv2.png"]
                }
            },
        ];





        const spinBtn = document.getElementById("spin-sticker-btn");

        const canvas = document.getElementById('canvas-container');
        const addStickerBtn = document.getElementById('add-sticker-btn');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const newBtn = document.getElementById('new-btn');
        const paletteContainer = document.getElementById('sticker-palette-container');
        const overlayContainer = document.getElementById('overlay-container');
        const letterSelect = document.getElementById('letter-select');
        const history = [];
        let activeSticker = null;
        let activePaletteSticker = null;
        let isRestoring = false;
        let redoStack = [];
        let initialX, initialY, offsetX, offsetY;
        let initialTouchDistance = 0;
        let initialStickerWidth = 0;
        let initialStickerHeight = 0;
        let initialCenter = { x: 0, y: 0 };
        let firstStickerAdded = false;

       function saveState() {
    if (isRestoring) return;
    const stickersOnCanvas = document.querySelectorAll('#canvas-container .sticker');
    const currentState = {
        stickers: []
    };
    stickersOnCanvas.forEach(sticker => {
        const stickerImg = sticker.querySelector('img');
        if (stickerImg) {
            const rotation = parseFloat(sticker.dataset.rotation) || 0;
            currentState.stickers.push({
                url: stickerImg.src,
                x: sticker.offsetLeft,
                y: sticker.offsetTop,
                width: sticker.offsetWidth,
                height: sticker.offsetHeight,
                rotation: rotation
            });
        }
    });
    history.push(currentState);
    redoStack = [];
    updateUndoRedoButtons();
}

        function loadState(state) {
    isRestoring = true;
    canvas.innerHTML = '';
    state.stickers.forEach(data => {
        addSticker(
            data.url,
            data.x,
            data.y,
            data.width,
            data.height,
            { suppressSave: true, rotation: parseFloat(data.rotation) || 0 }
        );
    });
    isRestoring = false;
    updateUndoRedoButtons();
}

function populatePalette() {
    stickerGroups.forEach(group => {
        const representativeUrl = group.urls["A"] ? group.urls["A"][0] : null;

        if (representativeUrl) {
            // ‚úÖ CORRECTION: Create the wrapper div
            const wrapper = document.createElement('div');
            wrapper.classList.add('palette-sticker-wrapper');
            // Set the tooltip text on the wrapper using a data attribute
            wrapper.dataset.label = group.name;

            const paletteSticker = document.createElement('img');
            paletteSticker.src = representativeUrl;
            paletteSticker.classList.add('palette-sticker');
            paletteSticker.dataset.group = group.name;

            paletteSticker.addEventListener('click', (e) => {
                if (activePaletteSticker === paletteSticker) {
                    hideOverlay();
                } else {
                    hideOverlay();
                    showOverlay(e, group.urls);
                    activePaletteSticker = paletteSticker;
                }
            });

            paletteSticker.draggable = true;
            paletteSticker.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('application/json', JSON.stringify({
                    url: e.target.src,
                    width: 120
                }));
                hideOverlay();
            });

            // ‚úÖ CORRECTION: Append the image to the wrapper, then the wrapper to the palette
            wrapper.appendChild(paletteSticker);
            paletteContainer.appendChild(wrapper);
        }
    });
}

        function deselectAllStickers() {
            document.querySelectorAll('.sticker').forEach(s => {
                s.classList.remove('selected');
            });
        }

        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

function getRandomStickerUrlFromGroups() {
    if (!stickerGroups || stickerGroups.length === 0) {
        console.log("‚ö†Ô∏è No stickerGroups available");
        return null;
    }

    // get current dropdown value
    const selectedLetter = document.getElementById("letter-select").value;

    // collect all stickers from all groups for the chosen letter
    const allStickers = stickerGroups.flatMap(group => {
        const urlsForLetter = group.urls[selectedLetter];
        return urlsForLetter ? urlsForLetter : [];
    });

    if (allStickers.length === 0) {
        console.log(`‚ö†Ô∏è No stickers found for letter ${selectedLetter}`);
        return null;
    }

    // pick one randomly
    const randomIndex = Math.floor(Math.random() * allStickers.length);
    return allStickers[randomIndex];
}

spinBtn.addEventListener("click", () => {
    const selectedLetter = letterSelect.value;

    // üîé find unlocked sticker of same letter
    let stickerDiv = document.querySelector(`#canvas-container .sticker[data-letter="${selectedLetter}"]:not(.locked)`);
    let stickerImg;

    if (!stickerDiv) {
        // ‚ûï No sticker of this letter, create new one
        const firstUrl = getRandomStickerByLetter(selectedLetter);
        if (firstUrl) {
            addOrReplaceSticker(firstUrl, selectedLetter);
            stickerDiv = document.querySelector(`#canvas-container .sticker[data-letter="${selectedLetter}"]:not(.locked)`);
            stickerImg = stickerDiv?.querySelector("img");
        } else {
            console.warn("‚ö†Ô∏è No sticker available for selected letter.");
            return;
        }
    } else {
        stickerImg = stickerDiv.querySelector("img");
    }

    // üé∞ Start spinning
    let spinCount = 0;
    const maxSpins = 15 + Math.floor(Math.random() * 10);

    const spinInterval = setInterval(() => {
        const nextUrl = getRandomStickerByLetter(selectedLetter); 
        if (nextUrl) {
            stickerImg.src = nextUrl;
        }

        spinCount++;
        if (spinCount >= maxSpins) {
            clearInterval(spinInterval);

            // üéâ Add pulse effect at the end
            stickerDiv.classList.add("pulse-effect");
            setTimeout(() => stickerDiv.classList.remove("pulse-effect"), 3000);

            saveState();
        }
    }, 100);
});

// MODIFIED: This function now correctly handles replacing the sticker and centering it
function addOrReplaceSticker(newUrl, letter) {
    const stickerSize = 120;
    const canvasWidth = canvas.offsetWidth;
    const canvasHeight = canvas.offsetHeight;
    const centerX = (canvasWidth / 2) - (stickerSize / 2);
    const centerY = (canvasHeight / 2) - (stickerSize / 2);

    // Find the group for this letter
    const groupObj = stickerGroups.find(g => g.urls[letter]);
    const groupName = groupObj ? groupObj.name : null;

    // Look for an unlocked sticker with the same letter
    const unlockedSticker = document.querySelector(`.sticker[data-letter="${letter}"]:not(.locked)`);

    if (unlockedSticker) {
        // Replace the image
        unlockedSticker.style.opacity = '0';
        const img = unlockedSticker.querySelector('img');
        img.src = newUrl;
        img.onload = () => {
            unlockedSticker.style.opacity = '1';
        };
        unlockedSticker.dataset.group = groupName;
    } else {
        // Create a new sticker in the center
        addSticker(newUrl, centerX, centerY, stickerSize, stickerSize, { 
            letter, 
            group: groupName 
        });
    }

    saveState();
}


function addSticker(url, x, y, width = 120, height = 120, opts = {}) {
    const { suppressSave = false, rotation = 0, letter = null , group = null} = opts;
    const sticker = document.createElement('div');
    sticker.classList.add('sticker');
    if (letter) sticker.dataset.letter = letter;
    if (group) sticker.dataset.group = group;

    let finalX, finalY;

    // Default placement (center if no coords given)
    if (x !== undefined && y !== undefined) {
        finalX = x;
        finalY = y;
    } else {
        const canvasWidth = canvas.offsetWidth;
        const canvasHeight = canvas.offsetHeight;
        finalX = (canvasWidth / 2) - (width / 2);
        finalY = (canvasHeight / 2) - (height / 2);
    }

    // --- üö´ Collision avoidance ---
    function isOverlapping(nx, ny) {
        const stickers = document.querySelectorAll('#canvas-container .sticker');
        return Array.from(stickers).some(s => {
            if (s === sticker) return false; // ignore self
            const sx = parseInt(s.style.left);
            const sy = parseInt(s.style.top);
            const sw = s.offsetWidth;
            const sh = s.offsetHeight;
            return !(nx + width <= sx || nx >= sx + sw || ny + height <= sy || ny >= sy + sh);
        });
    }

    // Try spiral search for a free spot
    let attempts = 0;
    let step = 20;
    while (isOverlapping(finalX, finalY) && attempts < 200) {
        finalX = (finalX + step) % (canvas.offsetWidth - width);
        finalY = (finalY + step) % (canvas.offsetHeight - height);
        attempts++;
    }

    // ‚úÖ Now we have a free spot
    sticker.style.left = `${finalX}px`;
    sticker.style.top = `${finalY}px`;
    sticker.style.width = `${width}px`;
    sticker.style.height = `${height}px`;
    sticker.style.transform = `rotate(${rotation}deg)`;
    sticker.dataset.rotation = rotation;

    // Image
    const stickerImg = document.createElement('img');
    stickerImg.crossOrigin = "Anonymous";
    stickerImg.src = url;
    stickerImg.draggable = false;
    sticker.appendChild(stickerImg);

 const groupBtn = document.createElement('div');
groupBtn.classList.add('sticker-btn', 'group-btn');
groupBtn.innerHTML = '<i data-lucide="layers"></i>';

groupBtn.addEventListener('click', (ev) => {
    ev.stopPropagation();

    const letter = sticker.dataset.letter;
    const url = sticker.querySelector('img').src;

    console.log('üìå Group button clicked');
    console.log('Sticker letter:', letter);
    console.log('Sticker URL:', url);

    // Find the group that actually contains this URL under this letter
    const group = stickerGroups.find(g => g.urls[letter]?.includes(url));

    if (group) {
        console.log('Found correct group:', group.name);
        showOverlay(ev, group.urls);
    } else {
        console.warn('‚ö†Ô∏è No matching group found for this sticker!');
    }
});

sticker.appendChild(groupBtn);


    const copyBtn = document.createElement('div');
    copyBtn.classList.add('copy-btn');
    copyBtn.innerHTML = `<svg class="copy-btn-icon" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="12" y1="8" x2="12" y2="16" />
        <line x1="8" y1="12" x2="16" y2="12" />
    </svg>`;

    copyBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    
    const stickerWidth = sticker.offsetWidth;
    const stickerHeight = sticker.offsetHeight;
    const newX = parseInt(sticker.style.left) + 10;
    const newY = parseInt(sticker.style.top) + 10;

    const letter = sticker.dataset.letter || null;
    const groupName = sticker.dataset.group || null;
    const rotation = parseFloat(sticker.dataset.rotation) || 0;

    addSticker(
    stickerImg.src,
    newX,
    newY,
    stickerWidth,
    stickerHeight,
    { 
        letter: sticker.dataset.letter, 
        group: sticker.dataset.group, 
        rotation: parseFloat(sticker.dataset.rotation) || 0 
    }
);

    saveState();
});

    const deleteBtn = document.createElement('div');
    deleteBtn.classList.add('delete-btn');
    deleteBtn.innerHTML = `<svg class="delete-btn-icon" viewBox="0 0 24 24">
        <line x1="5" y1="12" x2="19" y2="12" stroke="white" stroke-width="1" />
    </svg>`;
    deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        sticker.remove();
        saveState();
    });

    const resizeHandle = document.createElement('div');
    resizeHandle.classList.add('resize-handle');
    resizeHandle.innerHTML = `<svg class="resize-handle-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="15 3 21 3 21 9"></polyline>
        <polyline points="9 21 3 21 3 15"></polyline>
        <line x1="21" y1="3" x2="14" y2="10"></line>
        <line x1="3" y1="21" x2="10" y2="14"></line>
    </svg>`;

    
    
    const rotateHandle = document.createElement('div');
    rotateHandle.classList.add('rotate-handle');
    rotateHandle.innerHTML = `<svg class = "rotate-handle-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" 
        stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
        class="lucide lucide-rotate-ccw">
        <path d="M3 2v6h6"/>
        <path d="M3 13a9 9 0 1 0 3-7.7L3 8"/>
    </svg>`;
    sticker.appendChild(deleteBtn);
    sticker.appendChild(copyBtn);
    
    sticker.appendChild(rotateHandle);
    sticker.appendChild(groupBtn);

    function startInteraction(e) {
        if (e.target.closest('.delete-btn') || e.target.closest('.copy-btn') || e.target.closest('.group-btn') || e.target.closest('.rotate-handle')) {
            return;
        }
        
        deselectAllStickers();
        sticker.classList.add('selected');
        e.preventDefault();
        activeSticker = sticker;

        initialCenter.x = sticker.offsetLeft + sticker.offsetWidth / 2;
        initialCenter.y = sticker.offsetTop + sticker.offsetHeight / 2;

        if (e.touches && e.touches.length === 2) {
            initialTouchDistance = getTouchDistance(e.touches);
            initialStickerWidth = sticker.offsetWidth;
            initialStickerHeight = sticker.offsetHeight;
        } else if (e.touches && e.touches.length === 1) {
            const touch = e.touches[0];
            initialX = touch.clientX;
            initialY = touch.clientY;
            offsetX = sticker.offsetLeft;
            offsetY = sticker.offsetTop;
        } else {
            initialX = e.clientX;
            initialY = e.clientY;
            offsetX = sticker.offsetLeft;
            offsetY = sticker.offsetTop;
        }
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchmove', handleMove, { passive: false });
        document.addEventListener('touchend', handleEnd);
    }

    function handleMove(e) {
        if (!activeSticker) return;
        e.preventDefault();

        if (e.touches && e.touches.length === 2) {
            const newTouchDistance = getTouchDistance(e.touches);
            const scaleChange = newTouchDistance / initialTouchDistance;
            const newWidth = Math.max(initialStickerWidth * scaleChange, 30);
            const aspectRatio = initialStickerWidth / initialStickerHeight;
            const newHeight = newWidth / aspectRatio;
            activeSticker.style.width = `${newWidth}px`;
            activeSticker.style.height = `${newHeight}px`;
            activeSticker.style.left = `${initialCenter.x - newWidth / 2}px`;
            activeSticker.style.top = `${initialCenter.y - newHeight / 2}px`;
        } else {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const newX = offsetX + (clientX - initialX);
            const newY = offsetY + (clientY - initialY);
            activeSticker.style.left = `${newX}px`;
            activeSticker.style.top = `${newY}px`;
        }
    }

    function handleEnd() {
        document.removeEventListener('mousemove', handleMove);
        document.removeEventListener('mouseup', handleEnd);
        document.removeEventListener('touchmove', handleMove);
        document.removeEventListener('touchend', handleEnd);
        activeSticker = null;
        saveState();
    }

    function addResizeHandleListeners(handle, sticker) {
        let startX, startY, startWidth, startHeight, startLeft, startTop;

        const startResize = (e) => {
            e.stopPropagation();
            e.preventDefault();
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            startX = clientX;
            startY = clientY;
            startWidth = sticker.offsetWidth;
            startHeight = sticker.offsetHeight;
            startLeft = sticker.offsetLeft;
            startTop = sticker.offsetTop;
            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', endResize);
            document.addEventListener('touchmove', doResize, { passive: false });
            document.addEventListener('touchend', endResize);
        };

        const doResize = (e) => {
            e.stopPropagation();
            e.preventDefault();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const deltaX = clientX - startX;
            const newWidth = Math.max(startWidth + deltaX, 30);
            const aspectRatio = startWidth / startHeight;
            const newHeight = newWidth / aspectRatio;
            sticker.style.width = `${newWidth}px`;
            sticker.style.height = `${newHeight}px`;
            sticker.style.left = `${startLeft + (startWidth - newWidth) / 2}px`;
            sticker.style.top = `${startTop + (startHeight - newHeight) / 2}px`;
        };

        const endResize = () => {
            document.removeEventListener('mousemove', doResize);
            document.removeEventListener('mouseup', endResize);
            document.removeEventListener('touchmove', doResize);
            document.removeEventListener('touchend', endResize);
            saveState();
        };

        handle.addEventListener('mousedown', startResize);
        handle.addEventListener('touchstart', startResize);
    }

    addResizeHandleListeners(resizeHandle, sticker);

    function addRotationHandleListeners(handle, sticker) {
        let startAngle = 0;
        let startRotation = 0;
        let stickerCenter = {};
        let lastAngle = 0;

        const getAngle = (clientX, clientY) => {
            return Math.atan2(clientY - stickerCenter.y, clientX - stickerCenter.x) * 180 / Math.PI;
        };

        const startRotationHandler = (e) => {
            e.stopPropagation();
            e.preventDefault();
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const rect = sticker.getBoundingClientRect();

            stickerCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };

            startAngle = getAngle(clientX, clientY);
            lastAngle = startAngle;
            startRotation = parseFloat(sticker.dataset.rotation) || 0;

            document.addEventListener("mousemove", doRotate);
            document.addEventListener("mouseup", endRotation);
            document.addEventListener("touchmove", doRotate, { passive: false });
            document.addEventListener("touchend", endRotation);
        };

        const doRotate = (e) => {
            e.stopPropagation();
            e.preventDefault();

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            let currentAngle = getAngle(clientX, clientY);

            let delta = currentAngle - lastAngle;
            if (delta > 180) delta -= 360;
            if (delta < -180) delta += 360;

            startRotation += delta;
            lastAngle = currentAngle;

            sticker.style.transform = `rotate(${startRotation}deg)`;
            sticker.dataset.rotation = startRotation;
        };

        const endRotation = () => {
            document.removeEventListener("mousemove", doRotate);
            document.removeEventListener("mouseup", endRotation);
            document.removeEventListener("touchmove", doRotate);
            document.removeEventListener("touchend", endRotation);

            sticker.dataset.rotation = parseFloat(sticker.dataset.rotation) || 0;
            saveState();
        };

        handle.addEventListener("mousedown", startRotationHandler);
        handle.addEventListener("touchstart", startRotationHandler);
    }

    addRotationHandleListeners(rotateHandle, sticker);

    function addWheelResize(stickerImg) {
        let lastWheelTime = 0;
        let timeoutId = null;
        stickerImg.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (Date.now() - lastWheelTime > 200 || history.length === 0) {
                saveState();
            }
            const parent = stickerImg.parentElement;
            const delta = Math.sign(e.deltaY);
            const initialWidth = parent.offsetWidth;
            const initialHeight = parent.offsetHeight;
            const initialLeft = parent.offsetLeft;
            const initialTop = parent.offsetTop;
            const newSize = initialWidth + (delta * 10);
            const minSize = 30;
            if (newSize >= minSize) {
                const newHeight = newSize / (initialWidth / initialHeight);
                parent.style.width = `${newSize}px`;
                parent.style.height = `${newHeight}px`;
                parent.style.left = `${initialLeft + (initialWidth - newSize) / 2}px`;
                parent.style.top = `${initialTop + (initialHeight - newHeight) / 2}px`;
            }
            lastWheelTime = Date.now();
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                saveState();
            }, 200);
        });
    }

    addWheelResize(stickerImg);
    sticker.addEventListener('mousedown', startInteraction);
    sticker.addEventListener('touchstart', startInteraction);
    canvas.addEventListener('mousedown', (e) => {
        if (!e.target.closest('.sticker')) {
            deselectAllStickers();
        }
    });
    canvas.addEventListener('touchstart', (e) => {
        if (!e.target.closest('.sticker')) {
            deselectAllStickers();
        }
    });

    function updateButtonSizes() {
        const btnSize = sticker.offsetWidth * 0.2;
        [deleteBtn, copyBtn, resizeHandle, rotateHandle].forEach(btn => {
            btn.style.width = btnSize + 'px';
            btn.style.height = btnSize + 'px';
        });
        deleteBtn.style.top = deleteBtn.style.right = `${btnSize * 0.25}px`;
        copyBtn.style.top = copyBtn.style.left = `${btnSize * 0.25}px`;
        resizeHandle.style.bottom = resizeHandle.style.right = `${btnSize * 0.25}px`;
        rotateHandle.style.bottom = rotateHandle.style.left = `${btnSize * 0.25}px`;
    }

    updateButtonSizes();
    const observer = new ResizeObserver(updateButtonSizes);
    observer.observe(sticker);
    canvas.appendChild(sticker);
    
    if (!suppressSave && !isRestoring) {
        saveState();
    }
    
    return sticker;
}



        
        function hideOverlay() {
            overlayContainer.style.display = 'none';
            activePaletteSticker = null;
        }

        let activeGroupURLs = [];

        function showOverlay(e, urlsByLetter) {
    overlayContainer.innerHTML = '';

    // fill overlay
    for (const letter in urlsByLetter) {
        urlsByLetter[letter].forEach(url => {
            const overlaySticker = document.createElement('img');
            overlaySticker.src = url;
            overlaySticker.classList.add('overlay-sticker');
            overlaySticker.draggable = true;
            overlaySticker.addEventListener('dragstart', (e) => {
                e.stopPropagation();
                e.dataTransfer.setData('application/json', JSON.stringify({
                    url: e.target.src,
                    width: 120
                }));
            });
            overlaySticker.addEventListener('click', (e) => {
                e.stopPropagation();
                addSticker(url);
            });
            overlayContainer.appendChild(overlaySticker);
        });
    }

    // Position overlay
    const rect = e.target.getBoundingClientRect();
    let left = rect.right + 10;
    let top = rect.top;

    // if it would go off screen, flip to left
    if (left + overlayContainer.offsetWidth > window.innerWidth) {
        left = rect.left - overlayContainer.offsetWidth - 10;
    }
    // if it would go off bottom, shift up
    if (top + overlayContainer.offsetHeight > window.innerHeight) {
        top = window.innerHeight - overlayContainer.offsetHeight - 20;
    }

    overlayContainer.style.left = `${left}px`;
    overlayContainer.style.top = `${top}px`;
    overlayContainer.style.display = 'grid';
}

        document.addEventListener('click', (e) => {
            if (!paletteContainer.contains(e.target) && !overlayContainer.contains(e.target)) {
                hideOverlay();
            }
        });

        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            const data = e.dataTransfer.getData('application/json');
            if (data) {
                const { url, width } = JSON.parse(data);
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                addSticker(url, x, y, width);
            }
        });

        function updateUndoRedoButtons() {
            undoBtn.disabled = history.length <= 1;
            redoBtn.disabled = redoStack.length === 0;
        }

        undoBtn.addEventListener('click', () => {
            if (history.length > 1) {
                const lastState = history.pop();
                redoStack.push(lastState);
                loadState(history[history.length - 1]);
            }
        });

        redoBtn.addEventListener('click', () => {
            if (redoStack.length > 0) {
                const nextState = redoStack.pop();
                history.push(nextState);
                loadState(nextState);
            }
        });

        newBtn.addEventListener('click', () => {
            canvas.innerHTML = '';
            history.splice(0);
            redoStack.splice(0);
            saveState();
            firstStickerAdded = false;
        });

        function getRandomStickerByLetter(letter) {
            const matchingStickers = [];
            stickerGroups.forEach(group => {
                if (group.urls[letter]) {
                    matchingStickers.push(...group.urls[letter]);
                }
            });
            if (matchingStickers.length > 0) {
                const randomIndex = Math.floor(Math.random() * matchingStickers.length);
                return matchingStickers[randomIndex];
            } else {
                return null;
            }
        }

     addStickerBtn.addEventListener("click", () => {
    const selectedLetter = letterSelect.value;
    const url = getRandomStickerByLetter(selectedLetter);
    if (url) addOrReplaceSticker(url, selectedLetter);
});

        populatePalette();
        saveState();

        window.addEventListener('load', () => {
            if (window.lucide) {
                lucide.createIcons();
            }
        });
    </script>
</body>
</html>
