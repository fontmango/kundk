<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sticker Canvas</title>
    <style>
      
      img.protected {
  -webkit-touch-callout: none; /* disable "Save Image" on iOS Safari */
  -webkit-user-select: none;   /* prevent text/image selection */
  -webkit-user-drag: none;     /* prevent dragging image to new tab */
  user-select: none;
}
      
  .sticker-btn {
    position: absolute;
    width: 20%;
    height: 20%;
    border-radius: 50%;
    background-color: #c2bebeff;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 101;
    padding: 0;
    outline: none;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s ease, visibility 0.2s ease, transform 0.2s, background-color 0.2s;
}

/* Show buttons on hover or selected sticker */
.sticker:hover > .sticker-btn,
.sticker.selected > .sticker-btn {
    opacity: 1;
    visibility: visible;
}

/* Specific button positions */
.delete-btn {
    top: 5%;
    right: 5%;
}

.copy-btn {
    top: 5%;
    left: 5%;
}

.group-btn:hover {
    background-color: #2be7d8; /* A subtle hover color */
    transform: scale(1.1);
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
}

.group-btn {
    bottom: 5%;
    right: 5%;
}

/* Hover effects */
.sticker-btn:hover {
    transform: scale(1.1);
   
}

.sticker.locked .lock-btn {
    background-color: #ff9933; /* Override to orange when locked */
}


/* SVG sizing inside buttons */
.sticker-btn svg {
    width: 60%;
    height: 60%;
}

body {
    margin: 0;
    padding: 0;
    font-family: 'Inter', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
  
    box-sizing: border-box;
    overflow-x: hidden;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

#canvas-container {
    width: 90%;
    max-width: 600px;
    height: 80vh;
    background-color: #ffffff;
    border: 1px solid #e0e0e0;
    position: relative;
    margin-top: 10px;
    overflow: hidden;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    border-radius: 16px;
    touch-action: none;
}
      
      @media (max-width: 768px) {
    #canvas-container {
        /* On mobile, make the height 50% of the screen's height */
  
        /* You can also make it take the full width for more space */
        width: 100%;
    }
}



.sticker {
    position: absolute;
    height: auto;
    user-select: none;
    box-sizing: border-box;
    touch-action: none;
}

.sticker img {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

.sticker:active {
    cursor: grabbing;
    z-index: 100;
}

.sticker.locked {
    cursor: grab;
}

.sticker.locked:active {
    cursor: grabbing;
}

.sticker:focus {
    outline: none;
}

/* Base styles for buttons, with transitions for smooth fading */
.copy-btn,
.group-btn,
.delete-btn,
.lock-btn {
    position: absolute;
    width: 20%;
    height: 20%;
    border-radius: 50%;
    background-color: #c2bebeff;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 101;
    padding: 0;
    outline: none;
    -webkit-tap-highlight-color: transparent;

    /* These are the crucial lines for hiding and transitioning */
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s ease, visibility 0.2s ease, transform 0.2s, background-color 0.2s;
}

/* Specific button positions */
.delete-btn {
    top: 5%;
    right: 5%;
}

.copy-btn {
    top: 5%;
    left: 5%;
}


.group-btn svg {
    width: 16px;
    height: 16px;
}

/* Show buttons on hover or when the sticker has the 'selected' class */
.sticker:hover > .delete-btn,
.sticker:hover > .copy-btn,
.sticker:hover > .lock-btn,
.sticker.selected > .delete-btn,
.sticker.selected > .copy-btn,
.sticker.selected > .lock-btn {
    opacity: 1;
    visibility: visible;
}

/* Hover effects for buttons */
.copy-btn:hover {
    background-color: #6aa84fff;
    transform: scale(1.1);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.delete-btn:hover {
    background-color: #f26262ff;
    transform: scale(1.1);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.lock-btn:hover {
    transform: scale(1.1);
   
    
}



/* Bucket mode-specific overrides */
.bucket-active .sticker {
    border: none !important;
    transition: none !important;
}

.bucket-active .sticker .delete-btn,
.bucket-active .sticker .copy-btn,
.bucket-active .sticker .lock-btn,
.bucket-active .sticker .group-btn {
    display: none !important;
}

.bucket-active .sticker:active,
.bucket-active .sticker:hover {
    cursor: crosshair;
}

/* ... (rest of your CSS) ... */

/* Remaining CSS from your provided code */
.controls {
    display: flex;
    gap: 10px;
    align-items: center;
}

.ghost-sticker {
    position: fixed;
    pointer-events: none;
    z-index: 1000;
    opacity: 0.7;
    width: 100px;
    height: auto;
    transform: translate(-50%, -50%);
}

button {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: none;
    background: none;
    cursor: pointer;
    color: #333;
    transition: transform 0.2s, color 0.2s;
    outline: none;
    -webkit-tap-highlight-color: transparent;
}

button:focus,
button:active {
    outline: 0 !important;
    box-shadow: none !important;
}

button:hover {
    color: #000;
    transform: scale(1.1);
}

button.active {
    border-radius: 50%;
    background-color: #e0e0e0;
    transform: scale(1.05);
}

.icon {
    width: 1.4em;
    height: 1.4em;
    stroke: currentColor;
}

.color-palette-container {
    width: 90%;
    max-width: 600px;
    overflow-x: scroll;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    -ms-overflow-style: none;
    touch-action: pan-y;
}

.color-palette-container::-webkit-scrollbar {
    display: none;
}

.color-palette {
    display: flex;
    flex-wrap: nowrap;
    gap: 8px;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 3px;
    width: max-content;
}

.color-swatch {
    width: 25px;
    height: 25px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid transparent;
    transition: transform 0.2s, border-color 0.2s;
    flex-shrink: 0;
    outline: 0 !important;
    box-shadow: none !important;
    -webkit-tap-highlight-color: transparent;
    touch-action: none;
}

.color-swatch.active {
    transform: scale(1.2);
    border-color: #000000;
}

#sticker-palette-container {
    display: none;
}

.overlay {
    position: fixed;
    top: 45%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(255, 255, 255, 0.95);
    border: 1px solid #ccc;
    border-radius: 8px;
    padding: 10px;
    display: none;
    z-index: 200;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    width: 80%;
   
    overflow-y: auto;
    grid-template-columns: repeat(5, 1fr);
    gap: 10px;
}


.overlay.active {
    display: block;
}

.overlay-grid {
   
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 10px;
    overflow-y: auto;
    height: calc(100% - 40px);
    width: 100%;
}

.overlay-icon {
   
    max-width: 100%; /* Ensures it scales down on smaller screens */
    height: auto;
    aspect-ratio: 1/1;
    object-fit: contain;
    cursor: pointer;
    border-radius: 8px;
    transition: transform 0.2s;
    transform: scale(1);
    -webkit-tap-highlight-color: transparent;
    -webkit-focus-ring-color: transparent;
    outline: none;
}


.overlay-icon:hover {
    animation: pulse 1.5s infinite;
}

.overlay-sticker {
    width: 100%;
    height: auto;
    aspect-ratio: 1/1;
    object-fit: contain;
    cursor: pointer;
    border: 1px solid transparent;
    transition: transform 0.2s;
 -webkit-tap-highlight-color: transparent; /* iOS/Android WebKit */
  -webkit-focus-ring-color: transparent;    /* iOS Safari */
  outline: none;      
  
}

.overlay-sticker.active {
  position: relative;
}

.overlay-sticker.active::after {
  content: "";
  position: absolute;
  top: -5px;
  left: -5px;
  right: -5px;
  bottom: -5px;
  border-radius: 12px; /* adjust to match sticker shape */
  border: 2px solid #00bfff; /* pulse color */
  animation: pulse 1.5s infinite;
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.15);
  }
}


.overlay-sticker:hover {
    transform: scale(1.1);
}

.copy-btn-icon {
    width: 100%;
    height: 100%;
    fill: white;
    stroke: white;
}

.lock-btn-icon {
    width: 60%;
    height: 60%;
    fill: white;
    stroke: white;
}

.delete-btn-icon {
    width: 100%;
    height: 100%;
    fill: white;
    stroke: white;
}


.copy-btn:hover {
    background-color: #6aa84fff;
    transform: scale(1.1);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.delete-btn:hover {
    background-color: #f26262ff;
    transform: scale(1.1);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.pulse-effect {
  animation: pulse 0.5s ease-in-out;
}

@keyframes pulse {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.1);
  }
  100% {
    transform: scale(1);
  }
}
#sticker-overlay-container {
  position: fixed;                     /* modal */
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  
  width: 90vw;
  max-width: 500px;
  max-height: 80vh;                    /* stays inside screen */
  
  background-color: #fff;
  border-radius: 16px;
  box-shadow: 0 8px 30px rgba(0,0,0,0.15);
  z-index: 300;
  
  display: none;
  flex-direction: column;
  overflow: hidden;                    /* ‚úÖ never scroll here */
}

/* Other CSS remains the same */

.overlay-stickers-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
  gap: 15px;
  padding: 10px;
  
  flex: 1;                             /* take remaining space */
  overflow-y: auto;                    /* ‚úÖ scroll only here */
  overflow-x: hidden;                  /* ‚úÖ no horizontal scroll */
  max-height: 100%;                    /* constrained by parent */
}

.overlay-icons-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
  gap: 10px;
  padding: 10px;

  flex: 1;
  overflow-y: auto;    /* ‚úÖ scroll only here */
  overflow-x: hidden;  /* ‚úÖ no x-scroll */
}

.overlay-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    background: white;
    border-bottom: 1px solid #ccc;
    flex-shrink: 0;
}


.close-btn {
    position: absolute;
   
    
    color: #555;
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}


.close-btn {
    right: 0;
}

.overlay-close-btn:hover {
    transform: scale(1.1);
}

.overlay-title {
    flex-grow: 1;
    text-align: center;
    /* This is the key change: remove the default margin from the title */
    margin: 0;
    font-size: 16px; /* Adjust font size as needed */
    font-weight: 600;
}

#group-overlay-container {
    position: fixed;
    top: 45%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(255, 255, 255, 0.95);
    border: 1px solid #ccc;
    border-radius: 8px;
    padding: 10px;
    display: none;
    z-index: 200;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    width: 80%;
    max-width: 500px;
    max-height: 80vh;
    overflow-y: auto;
    
    /* Change to flexbox for vertical stacking */
    display: none;
    flex-direction: column;
}
.tool-btn.active {
    background-color: #a0a0a0;
    border-style: inset;
}
    </style>

    <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body>
  


    <div id="canvas-container"></div>
    <div id="overlay-container"></div>

  <div class="controls">
  <button id="brush-btn">üñåÔ∏è</button>
   <button id="spin-sticker-btn" title="Spin Random">
  <i data-lucide="dice-6" class="icon"></i>
</button>
    
        <button id="add-sticker-btn" title="Add Random">
            <i data-lucide="plus" class="icon"></i>
        </button>

        <button id="sticker-picker-btn" title="Choose Sticker">
            <i data-lucide="sticker" class="icon"></i>
        </button>

        <button id="undo-btn" title="Undo">
            <i data-lucide="undo-2" class="icon"></i>
        </button>

        <button id="redo-btn" title="Redo">
            <i data-lucide="redo-2" class="icon"></i>
        </button>

        <button id="eraser-btn" title="Erase">
            <i data-lucide="eraser" class="icon"></i>
        </button>

    </div>
  
  
    <div class="color-palette-container">
        <div class="color-palette" id="color-palette"></div>
    </div>
        <div id="sticker-overlay-container"></div>

    <div id="group-overlay-container"></div>

    <script>
    
document.addEventListener('DOMContentLoaded', () => {

    // --- Element Selectors ---
    const canvas = document.getElementById('canvas-container');
    const spinBtn = document.getElementById("spin-sticker-btn");
    const addStickerBtn = document.getElementById('add-sticker-btn');
    const undoBtn = document.getElementById('undo-btn');
    const redoBtn = document.getElementById('redo-btn');
    const colorPalette = document.getElementById('color-palette');
    const stickerPickerBtn = document.getElementById('sticker-picker-btn');
    const groupOverlayContainer = document.getElementById('group-overlay-container');
    const stickerOverlayContainer = document.getElementById('sticker-overlay-container');
    const eraserBtn = document.getElementById('eraser-btn');
    const brushBtn = document.getElementById('brush-btn');

    // --- State Variables ---
    const history = [];
    let redoStack = [];
    let isRestoring = false;

    // --- Unified Tool & Interaction State ---
    let currentTool = 'move';
    let selectedColor = null;
    let brushSize = 20;

    let activeSticker = null;
    let isDrawing = false;
    let isInteracting = false;
    let activeCanvas = null;
    let activeCtx = null;
    let initialInteractionData = {};
    let lastX = 0, lastY = 0;
    let strokeOriginImageData = null;
    let insideMask = null; // Holds the map of valid pixels for the current stroke

    const transparentColor = { type: 'erase' };

    // --- Sticker & Color Data ---
    const proxyUrl = 'https://api.allorigins.win/raw?url=';
    const stickerGroups = [{ name: "Kids", urls: [`${proxyUrl}https://static.wixstatic.com/media/990059_cff7ab1b0c9848f7b2a118d9947ba1f2~mv2.png`, `${proxyUrl}https://static.wixstatic.com/media/990059_e82d3988155f491e8eccd350a96c8474~mv2.png`, `${proxyUrl}https://static.wixstatic.com/media/990059_b5d619b163ad4c92ac030ee02dd81156~mv2.png`, `${proxyUrl}https://static.wixstatic.com/media/990059_c7513aaacb8f480ab18fa0644fdead37~mv2.png`, `${proxyUrl}https://static.wixstatic.com/media/990059_c41b8293c1ca448abbd7aabe3a0f5b01~mv2.png`, `${proxyUrl}https://static.wixstatic.com/media/990059_e69b4981274e46a180888db9a034c333~mv2.png`, `${proxyUrl}https://static.wixstatic.com/media/990059_e45fc6d5053f4b5f9817162bdd19dd83~mv2.png`, `${proxyUrl}https://static.wixstatic.com/media/990059_5bec1b1a0f4e4eb6be3b3816f3e50bee~mv2.png`] }, ];
    const colors = ['#800020', '#A52A2A', '#ff4040', '#FF0000', '#FF6347', '#FF7F50', '#f08080', '#FA8072', '#ff7373', '#ff1493', '#FF69B4', '#ff00ff', '#ff80ed', '#ff71ce', '#FFC0CB', '#ffb3ba', '#ffe4e1', '#a67c00', '#D2691E', '#CD5C5C', '#FFA500', '#FF8C00', '#FFC04C', '#FFD700', '#FFFF00', '#ffff66', '#fffb96', '#065535', '#013220', '#008000', '#808000', '#3CB371', '#9ACD32', '#ADFF2F', '#05ffa1', '#b4eeb4', '#000080', '#0e2f44', '#0000FF', '#4169E1', '#1E90FF', '#0a75ad', '#6897bb', '#b0e0e6', '#87CEFA', '#01cdfe', '#40E0D0', '#008080', '#00ffff', '#ddfffc', '#4B0082', '#660066', '#800080', '#8a2be2', '#b967ff', '#BA55D3', '#DA70D6', '#e6e6fa', '#ccccff', '#333333', '#666666', '#808080', '#A9A9A9', '#C0C0C0', '#cccccc', '#dddddd', '#CBBEB5', '#c39797', '#ffdab9', '#faebd7', ];

    // --- Core Interaction & Tooling Functions ---

    function setActiveTool(tool) { const newTool = (currentTool === tool && tool !== 'move') ? 'move' : tool; currentTool = newTool; document.body.className = ''; document.querySelectorAll('button.active').forEach(b => b.classList.remove('active')); document.querySelectorAll('.color-swatch.active').forEach(s => s.classList.remove('active')); switch (currentTool) { case 'bucket': document.body.classList.add('bucket-active'); document.querySelector(`.color-swatch[style*="${selectedColor}"]`)?.classList.add('active'); break; case 'brush': document.body.classList.add('brush-active'); brushBtn?.classList.add('active'); const activeColorSwatch = document.querySelector(`.color-swatch[style*="${selectedColor}"]`); if (activeColorSwatch) activeColorSwatch.classList.add('active'); break; case 'eraser': document.body.classList.add('brush-active'); eraserBtn?.classList.add('active'); selectedColor = transparentColor; break; case 'move': default: document.body.classList.add('move-active'); selectedColor = null; break; } }
    
    function draw(e) {
        if (!isDrawing || !activeCtx || !activeSticker) return;
        const stickerImg = activeSticker.querySelector('img');
        const rect = stickerImg.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        if (clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom) {
            lastX = -1;
            return;
        }

        const [currentX, currentY] = getCanvasCoordinates(clientX, clientY, rect);

        if (lastX === -1) {
            const currentIdx = Math.round(currentY) * activeCanvas.width + Math.round(currentX);
            if (currentTool === 'eraser' || (insideMask && insideMask[currentIdx])) {
                 lastX = currentX;
                 lastY = currentY;
            } else {
                return; // Don't resume drawing if re-entering an invalid area
            }
        }

        const dist = Math.hypot(currentX - lastX, currentY - lastY);
        const angle = Math.atan2(currentY - lastY, currentX - lastX);
        const imageDataToPaint = activeCtx.getImageData(0, 0, activeCanvas.width, activeCanvas.height);
        const rgbColor = currentTool === 'eraser' ? [0, 0, 0, 0] : hexToRgb(selectedColor);
        if (!rgbColor) return;

        for (let i = 0; i < dist; i++) {
            const x = Math.round(lastX + (Math.cos(angle) * i));
            const y = Math.round(lastY + (Math.sin(angle) * i));
            const idx = y * activeCanvas.width + x;
            if (currentTool === 'brush' && (!insideMask || !insideMask[idx])) {
                continue;
            }
            paintAt(x, y, imageDataToPaint, rgbColor);
        }

        const cx = Math.round(currentX), cy = Math.round(currentY);
        const currentIdx = cy * activeCanvas.width + cx;
        if (currentTool === 'eraser' || (insideMask && insideMask[currentIdx])) {
            paintAt(cx, cy, imageDataToPaint, rgbColor);
        }
        
        activeCtx.putImageData(imageDataToPaint, 0, 0);
        stickerImg.src = activeCanvas.toDataURL();
        lastX = currentX;
        lastY = currentY;
    }

    function getCanvasCoordinates(clientX, clientY, rect) { if (!activeCanvas) return [0, 0]; const imgRatio = activeCanvas.width / activeCanvas.height; const rectRatio = rect.width / rect.height; let scale, offsetX = 0, offsetY = 0; if (rectRatio > imgRatio) { const actualWidth = rect.height * imgRatio; scale = activeCanvas.height / rect.height; offsetX = (rect.width - actualWidth) / 2; } else { const actualHeight = rect.width / imgRatio; scale = activeCanvas.width / rect.width; offsetY = (rect.height - actualHeight) / 2; } const x = (clientX - rect.left - offsetX) * scale; const y = (clientY - rect.top - offsetY) * scale; return [x, y]; }
    function paintAt(x, y, imageData, color) { const { width, data } = imageData; for (let i = -brushSize; i < brushSize; i++) { for (let j = -brushSize; j < brushSize; j++) { if (i * i + j * j < brushSize * brushSize) { const pixelX = Math.round(x + i); const pixelY = Math.round(y + j); if (pixelX < 0 || pixelX >= width || pixelY < 0 || pixelY >= imageData.height) continue; const originIndex = (pixelY * width + pixelX) * 4; if (strokeOriginImageData && originIndex >= 0 && originIndex < strokeOriginImageData.data.length) { const r = strokeOriginImageData.data[originIndex], g = strokeOriginImageData.data[originIndex + 1], b = strokeOriginImageData.data[originIndex + 2], a = strokeOriginImageData.data[originIndex + 3]; if (r < 50 && g < 50 && b < 50 && a > 50) continue; } const paintIndex = (pixelY * width + pixelX) * 4; if (currentTool === 'eraser') { data[paintIndex + 3] = 0; } else { data[paintIndex] = color[0]; data[paintIndex + 1] = color[1]; data[paintIndex + 2] = color[2]; data[paintIndex + 3] = 255; } } } } }
    function addSticker(url, x, y, width = 200, height = 200, opts = {}) { const { suppressSave = false, group } = opts; const sticker = document.createElement('div'); sticker.className = 'sticker'; sticker.style.width = `${width}px`; sticker.style.height = `${height}px`; sticker.style.left = `${x}px`; sticker.style.top = `${y}px`; sticker.dataset.group = group || 'default'; const stickerImg = document.createElement('img'); stickerImg.crossOrigin = "Anonymous"; stickerImg.src = url; stickerImg.draggable = false; stickerImg.className = "protected"; sticker.appendChild(stickerImg); addInteractionButtons(sticker, stickerImg); sticker.addEventListener('mousedown', startInteraction); sticker.addEventListener('touchstart', startInteraction, { passive: false }); sticker.addEventListener('wheel', handleWheelResize, { passive: false }); canvas.appendChild(sticker); if (!suppressSave && !isRestoring) { saveState(); } return sticker; }
    function addInteractionButtons(sticker, stickerImg) { const copyBtn = document.createElement('div'); copyBtn.className = 'copy-btn sticker-btn'; copyBtn.innerHTML = `<svg class="copy-btn-icon" viewBox="0 0 24 24"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>`; copyBtn.addEventListener('click', (e) => { e.stopPropagation(); addSticker(stickerImg.src, parseInt(sticker.style.left) + 20, parseInt(sticker.style.top) + 20, sticker.offsetWidth, sticker.offsetHeight, { group: sticker.dataset.group }); }); const deleteBtn = document.createElement('div'); deleteBtn.className = 'delete-btn sticker-btn'; deleteBtn.innerHTML = `<svg class="delete-btn-icon" viewBox="0 0 24 24"><path d="M18 6 6 18"></path><path d="m6 6 12 12"></path></svg>`; deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); saveState(); sticker.remove(); }); const lockBtn = document.createElement('div'); lockBtn.className = 'lock-btn sticker-btn'; lockBtn.innerHTML = `<svg class="lock-btn-icon" viewBox="0 0 24 24"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>`; lockBtn.addEventListener('click', (e) => { e.stopPropagation(); sticker.classList.toggle('locked'); sticker.classList.remove('selected'); saveState(); }); const groupBtn = document.createElement('div'); groupBtn.className = 'group-btn sticker-btn'; groupBtn.innerHTML = `<svg class="group-btn-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="6" x2="20" y2="6"></line><line x1="4" y1="12" x2="20" y2="12"></line><line x1="4" y1="18" x2="20" y2="18"></line></svg>`; groupBtn.addEventListener('click', (e) => { e.stopPropagation(); const group = stickerGroups.find(g => g.name === sticker.dataset.group); if (group) showStickerOverlay(group.urls, group.name); }); sticker.appendChild(deleteBtn); sticker.appendChild(copyBtn); sticker.appendChild(lockBtn); sticker.appendChild(groupBtn); }
    function addOrReplaceSticker(newUrl, groupName = null) { const unlockedSticker = document.querySelector('.sticker:not(.locked)'); const stickerSize = 150; const centerX = (canvas.offsetWidth / 2) - (stickerSize / 2); const centerY = (canvas.offsetHeight / 2) - (stickerSize / 2); if (unlockedSticker) { const stickerImg = unlockedSticker.querySelector('img'); stickerImg.src = newUrl; unlockedSticker.style.width = `${stickerSize}px`; unlockedSticker.style.height = `${stickerSize}px`; unlockedSticker.style.left = `${centerX}px`; unlockedSticker.style.top = `${centerY}px`; if (groupName) unlockedSticker.dataset.group = groupName; } else { addSticker(newUrl, centerX, centerY, stickerSize, stickerSize, { group: groupName }); } saveState(); }
    
    // --- Unified Interaction Handlers ---

    function startInteraction(e) {
        const sticker = e.currentTarget;
        if (sticker.classList.contains('locked') || e.target.closest('.sticker-btn')) return;
        e.preventDefault();
        activeSticker = sticker;

        if (currentTool === 'brush' || currentTool === 'eraser') {
            const stickerImg = activeSticker.querySelector('img');
            const setupBrush = (img, event) => {
                activeCanvas = document.createElement('canvas');
                activeCanvas.width = img.naturalWidth;
                activeCanvas.height = img.naturalHeight;
                activeCtx = activeCanvas.getContext('2d', { willReadFrequently: true });
                activeCtx.drawImage(img, 0, 0);

                const clientX = event.touches ? event.touches[0].clientX : event.clientX;
                const clientY = event.touches ? event.touches[0].clientY : event.clientY;
                const rect = stickerImg.getBoundingClientRect();
                const [startX, startY] = getCanvasCoordinates(clientX, clientY, rect);
                
                if (currentTool === 'brush') {
                    insideMask = computeEnclosedMask(Math.round(startX), Math.round(startY), activeCanvas);
                    if (!insideMask) {
                        activeSticker = null; activeCanvas = null; return;
                    }
                }
                
                strokeOriginImageData = activeCtx.getImageData(0, 0, activeCanvas.width, activeCanvas.height);
                isDrawing = true;
                [lastX, lastY] = [startX, startY];
                draw(event);

                document.addEventListener('mousemove', draw);
                document.addEventListener('touchmove', draw, { passive: false });
                document.addEventListener('mouseup', handleEnd);
                document.addEventListener('touchend', handleEnd);
            };

            if (stickerImg.complete && stickerImg.naturalWidth > 0) {
                setupBrush(stickerImg, e);
            } else {
                stickerImg.onload = () => setupBrush(stickerImg, e);
            }
        } else if (currentTool === 'bucket') {
            if (selectedColor) { recolorSticker(activeSticker.querySelector('img'), selectedColor, e); }
        } else { // 'move' tool
            isInteracting = true;
            deselectAllStickers();
            activeSticker.classList.add('selected');
            if (e.touches) {
                if (e.touches.length === 1) { const touch = e.touches[0]; initialInteractionData = { x: touch.clientX, y: touch.clientY, offsetX: activeSticker.offsetLeft, offsetY: activeSticker.offsetTop };
                } else if (e.touches.length === 2) { initialInteractionData = { pinchDistance: Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY), width: activeSticker.offsetWidth }; }
            } else { initialInteractionData = { x: e.clientX, y: e.clientY, offsetX: activeSticker.offsetLeft, offsetY: activeSticker.offsetTop }; }
            document.addEventListener('mousemove', handleMove); document.addEventListener('touchmove', handleMove, { passive: false });
            document.addEventListener('mouseup', handleEnd); document.addEventListener('touchend', handleEnd);
        }
    }

    function handleMove(e) { if (!activeSticker || (!isInteracting && !isDrawing)) return; e.preventDefault(); if (isInteracting) { if (e.touches) { if (e.touches.length === 1) { const touch = e.touches[0]; const dx = touch.clientX - initialInteractionData.x; const dy = touch.clientY - initialInteractionData.y; activeSticker.style.left = `${initialInteractionData.offsetX + dx}px`; activeSticker.style.top = `${initialInteractionData.offsetY + dy}px`; } else if (e.touches.length === 2) { const currentPinch = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); const scaleFactor = currentPinch / initialInteractionData.pinchDistance; const newWidth = Math.max(30, initialInteractionData.width * scaleFactor); activeSticker.style.width = `${newWidth}px`; activeSticker.style.height = 'auto'; } } else { const dx = e.clientX - initialInteractionData.x; const dy = e.clientY - initialInteractionData.y; activeSticker.style.left = `${initialInteractionData.offsetX + dx}px`; activeSticker.style.top = `${initialInteractionData.offsetY + dy}px`; } } }
    
    function handleEnd() {
        if (isInteracting && activeSticker) {
            activeSticker.classList.remove('selected');
        }
        if (isDrawing || isInteracting) {
            saveState();
        }
        isDrawing = false; isInteracting = false; activeSticker = null; activeCanvas = null; activeCtx = null;
        lastX = 0; lastY = 0;
        strokeOriginImageData = null; 
        insideMask = null; // Clear the mask
        document.removeEventListener('mousemove', handleMove); document.removeEventListener('mouseup', handleEnd);
        document.removeEventListener('touchmove', handleMove); document.removeEventListener('touchend', handleEnd);
        document.removeEventListener('mousemove', draw); document.removeEventListener('touchmove', draw);
    }

    function handleWheelResize(e) { e.preventDefault(); const sticker = e.currentTarget; if (sticker.classList.contains('locked')) return; const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1; const newWidth = Math.max(30, sticker.offsetWidth * scaleFactor); sticker.style.width = `${newWidth}px`; sticker.style.height = `auto`; saveState(); }
    
    // --- FIX: High-performance enclosure check ---
    function computeEnclosedMask(startX, startY, canvas) {
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const { width, height } = canvas;
        if (width === 0 || height === 0) return null;

        const imgData = ctx.getImageData(0, 0, width, height);
        const data = imgData.data;
        const startIndex = (startY * width + startX) * 4;

        const r = data[startIndex], g = data[startIndex + 1], b = data[startIndex + 2], a = data[startIndex + 3];
        if ((r < 50 && g < 50 && b < 50 && a > 50) || a < 10) {
            return null; // Don't start on a black line or fully transparent area
        }

        const mask = new Uint8Array(width * height);
        const stack = [[startX, startY]];
        mask[startY * width + startX] = 1;

        while (stack.length) {
            const [x, y] = stack.pop();
            const neighbors = [[x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]];
            for (const [nx, ny] of neighbors) {
                if (nx < 0 || nx >= width || ny < 0 || ny >= height) {
                    return null; // Leaks outside, so it's not enclosed
                }
                const idx = ny * width + nx;
                if (mask[idx]) continue;
                const di = idx * 4;
                const R = data[di], G = data[di + 1], B = data[di + 2], A = data[di + 3];
                const isBoundary = (R < 50 && G < 50 && B < 50 && A > 50) || (A < 10);
                if (!isBoundary) {
                    mask[idx] = 1;
                    stack.push([nx, ny]);
                }
            }
        }
        return mask;
    }

    // --- Coloring, History, and other functions ---
    function hexToRgb(colorStr) { if (!colorStr) return null; if (colorStr.startsWith('rgb')) { const parts = colorStr.match(/\d+/g); return [parseInt(parts[0]), parseInt(parts[1]), parseInt(parts[2])]; } const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(colorStr); return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : null; }
    function recolorSticker(stickerImg, fillColor, e) { if (!stickerImg.complete || stickerImg.naturalWidth === 0) return; const rect = stickerImg.getBoundingClientRect(); const imgRatio = stickerImg.naturalWidth / stickerImg.naturalHeight; const rectRatio = rect.width / rect.height; let contentX = 0, contentY = 0, contentWidth = rect.width, contentHeight = rect.height; if (rectRatio > imgRatio) { contentHeight = rect.height; contentWidth = rect.height * imgRatio; contentX = (rect.width - contentWidth) / 2; } else { contentWidth = rect.width; contentHeight = rect.width / imgRatio; contentY = (rect.height - contentHeight) / 2; } const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY; let clickX = Math.floor(((clientX - rect.left - contentX) / contentWidth) * stickerImg.naturalWidth); let clickY = Math.floor(((clientY - rect.top - contentY) / contentHeight) * stickerImg.naturalHeight); clickX = Math.max(0, Math.min(clickX, stickerImg.naturalWidth - 1)); clickY = Math.max(0, Math.min(clickY, stickerImg.naturalHeight - 1)); const canvasEl = document.createElement("canvas"); canvasEl.width = stickerImg.naturalWidth; canvasEl.height = stickerImg.naturalHeight; const ctx = canvasEl.getContext("2d", { willReadFrequently: true }); ctx.drawImage(stickerImg, 0, 0); const imgData = ctx.getImageData(0, 0, canvasEl.width, canvasEl.height); const data = imgData.data; const { width, height } = canvasEl; const isEraser = fillColor && fillColor.type === 'erase'; const [r, g, b] = isEraser ? [0, 0, 0] : hexToRgb(fillColor); const blackThreshold = 30, tolerance = 30; const startIndex = (clickY * width + clickX) * 4; const targetColor = [data[startIndex], data[startIndex + 1], data[startIndex + 2], data[startIndex + 3]]; if (targetColor[3] > 0 && targetColor[0] < blackThreshold && targetColor[1] < blackThreshold && targetColor[2] < blackThreshold) return; if (!isEraser && targetColor[0] === r && targetColor[1] === g && targetColor[2] === b) return; const stack = [[clickX, clickY]]; const visited = new Uint8Array(width * height); while (stack.length) { let [x, y] = stack.pop(); let left = x; while (left >= 0 && !visited[y * width + left] && isFillable(left, y)) left--; left++; let right = x; while (right < width && !visited[y * width + right] && isFillable(right, y)) right++; right--; for (let i = left; i <= right; i++) { const idx = y * width + i; visited[idx] = 1; const di = idx * 4; if (isEraser) { data[di + 3] = 0; } else { data[di] = r; data[di + 1] = g; data[di + 2] = b; data[di + 3] = 255; } } scan(y - 1, left, right); scan(y + 1, left, right); } function isFillable(px, py) { if (px < 0 || px >= width || py < 0 || py >= height) return false; const idx = py * width + px; if (visited[idx]) return false; const di = idx * 4; const R = data[di], G = data[di + 1], B = data[di + 2], A = data[di + 3]; if (A > 0 && R < blackThreshold && G < blackThreshold && B < blackThreshold) return false; if (targetColor[3] === 0) return A === 0; return Math.abs(R - targetColor[0]) <= tolerance && Math.abs(G - targetColor[1]) <= tolerance && Math.abs(B - targetColor[2]) <= tolerance && Math.abs(A - targetColor[3]) <= tolerance; } function scan(y, lx, rx) { if (y < 0 || y >= height) return; for (let x = lx; x <= rx; x++) { if (!visited[y * width + x] && isFillable(x, y)) { stack.push([x, y]); while (x <= rx && isFillable(x, y)) x++; } } } ctx.putImageData(imgData, 0, 0); stickerImg.src = canvasEl.toDataURL(); saveState(); }
    function saveState() { if (isRestoring) return; const stickersOnCanvas = document.querySelectorAll('#canvas-container .sticker'); const currentState = { stickers: [] }; stickersOnCanvas.forEach(sticker => { const stickerImg = sticker.querySelector('img'); if (stickerImg) { currentState.stickers.push({ url: stickerImg.src, x: sticker.offsetLeft, y: sticker.offsetTop, width: sticker.offsetWidth, height: sticker.offsetHeight, locked: sticker.classList.contains('locked'), groupName: sticker.dataset.group }); } }); const prevState = history[history.length - 1]; if (JSON.stringify(prevState) !== JSON.stringify(currentState)) { history.push(currentState); } redoStack = []; updateUndoRedoButtons(); }
    function loadState(state) { isRestoring = true; canvas.innerHTML = ''; if (state && state.stickers) { state.stickers.forEach(data => { const newSticker = addSticker(data.url, data.x, data.y, data.width, data.height, { suppressSave: true, group: data.groupName }); if (data.locked) newSticker.classList.add('locked'); }); } isRestoring = false; updateUndoRedoButtons(); }
    function updateUndoRedoButtons() { undoBtn.disabled = history.length <= 1; redoBtn.disabled = redoStack.length === 0; }
    function deselectAllStickers() { document.querySelectorAll('.sticker.selected').forEach(s => s.classList.remove('selected')); }
    function preloadStickers(urls) { return Promise.all(urls.map(url => new Promise((resolve, reject) => { const img = new Image(); img.src = url; img.onload = resolve; img.onerror = reject; }))); }
    function getRandomStickerUrlFromGroups() { if (!stickerGroups || stickerGroups.length === 0) return null; const allStickers = stickerGroups.flatMap(group => group.urls.map(url => ({ url, group: group.name }))); if (allStickers.length === 0) return null; return allStickers[Math.floor(Math.random() * allStickers.length)]; }
    function populateColorPalette() { colors.forEach(color => { const swatch = document.createElement('div'); swatch.className = 'color-swatch'; swatch.style.backgroundColor = color; colorPalette.appendChild(swatch); }); }
    function addSwipeFunctionality() { /* Your existing swipe logic */ }
    function hideOverlays() { groupOverlayContainer.style.display = 'none'; stickerOverlayContainer.style.display = 'none'; }
    function showGroupOverlay() { hideOverlays(); groupOverlayContainer.innerHTML = ''; const header = document.createElement('div'); header.className = 'overlay-header'; const title = document.createElement('h2'); title.textContent = "Sticker ausw√§hlen"; title.className = 'overlay-title'; const closeBtn = document.createElement('button'); closeBtn.textContent = '‚úï'; closeBtn.className = 'close-btn'; closeBtn.onclick = hideOverlays; header.append(title, closeBtn); const iconsGrid = document.createElement('div'); iconsGrid.className = 'overlay-icons-grid'; groupOverlayContainer.append(header, iconsGrid); groupOverlayContainer.style.display = 'flex'; stickerGroups.forEach((group) => { if (group.urls && group.urls.length > 0) { const groupIcon = document.createElement('img'); groupIcon.className = 'overlay-icon'; groupIcon.src = group.urls[0]; groupIcon.onclick = () => showStickerOverlay(group.urls, group.name); iconsGrid.appendChild(groupIcon); } }); }
    function showStickerOverlay(urls, groupName) { hideOverlays(); stickerOverlayContainer.innerHTML = ''; const header = document.createElement('div'); header.className = 'overlay-header'; const title = document.createElement('h2'); title.textContent = groupName; title.className = 'overlay-title'; const closeBtn = document.createElement('button'); closeBtn.textContent = '‚úï'; closeBtn.className = 'close-btn'; closeBtn.onclick = hideOverlays; header.append(title, closeBtn); const grid = document.createElement('div'); grid.className = 'overlay-stickers-grid'; stickerOverlayContainer.append(header, grid); stickerOverlayContainer.style.display = 'flex'; urls.forEach(url => { const stickerImg = document.createElement('img'); stickerImg.className = 'overlay-sticker'; stickerImg.src = url; stickerImg.onclick = () => { addOrReplaceSticker(url, groupName); hideOverlays(); }; grid.appendChild(stickerImg); }); }
    
    // --- Event Listeners Setup ---
    brushBtn?.addEventListener('click', () => { if (!selectedColor || selectedColor.type === 'erase') selectedColor = colors[0]; setActiveTool('brush'); });
    eraserBtn?.addEventListener('click', () => setActiveTool('eraser'));
    colorPalette.addEventListener('click', (e) => { if (e.target.classList.contains('color-swatch')) { const clickedColor = e.target.style.backgroundColor; if (selectedColor === clickedColor && currentTool === 'bucket') { setActiveTool('move'); } else { selectedColor = clickedColor; setActiveTool('bucket'); } } });
    undoBtn.addEventListener('click', () => { if (history.length > 1) { redoStack.push(history.pop()); loadState(history[history.length - 1]); } });
    redoBtn.addEventListener('click', () => { if (redoStack.length > 0) { const nextState = redoStack.pop(); history.push(nextState); loadState(nextState); } });
    addStickerBtn.addEventListener('click', () => { const randomSticker = getRandomStickerUrlFromGroups(); if (randomSticker) addOrReplaceSticker(randomSticker.url, randomSticker.group); });
    spinBtn.addEventListener("click", async () => { let targetStickerDiv = document.querySelector('.sticker:not(.locked)'); if (!targetStickerDiv) { const randomSticker = getRandomStickerUrlFromGroups(); if (randomSticker) targetStickerDiv = addSticker(randomSticker.url, 120, 120, 150, 150, { group: randomSticker.group }); else return; } const stickerPool = stickerGroups.flatMap(g => g.urls.map(url => ({ url, group: g.name }))); if (stickerPool.length === 0) return; await preloadStickers(stickerPool.map(s => s.url)); const stickerImg = targetStickerDiv.querySelector('img'); let spinCount = 0; const maxSpins = 20; const spinInterval = setInterval(() => { const nextSticker = stickerPool[Math.floor(Math.random() * stickerPool.length)]; stickerImg.src = nextSticker.url; targetStickerDiv.dataset.group = nextSticker.group; spinCount++; if (spinCount >= maxSpins) { clearInterval(spinInterval); saveState(); } }, 100); });
    stickerPickerBtn.addEventListener('click', showGroupOverlay);
    document.addEventListener('click', (e) => { if (!groupOverlayContainer.contains(e.target) && !stickerOverlayContainer.contains(e.target) && !stickerPickerBtn.contains(e.target)) { hideOverlays(); } });
    document.addEventListener("contextmenu", (e) => { if (e.target.tagName === "IMG" && e.target.classList.contains("protected")) e.preventDefault(); }, false);
    window.addEventListener('load', () => { if (!document.querySelector('.sticker')) { const randomSticker = getRandomStickerUrlFromGroups(); if (randomSticker) addOrReplaceSticker(randomSticker.url, randomSticker.group); } setActiveTool('move'); });

    // --- Initialize App ---
    populateColorPalette();
    addSwipeFunctionality();
    saveState();
    if (window.lucide) { lucide.createIcons(); }
});
    
    </script>
</body>
</html>
